ğŸ“¦ ì „ì²´ ê²Œì„ ì½”ë“œ
ì•„ë˜ì˜ ëª¨ë“  ì½”ë“œë¥¼ ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ“ index.html
HTML

    < !DOCTYPE html >
        <html lang="ko" >
            <head>
            <meta charset="UTF-8" />
                <link rel="icon" type = "image/svg+xml" href = "/vite.svg" />
                    <meta name="viewport" content = "width=device-width, initial-scale=1.0" />
                        <title>ë°”ëŒì˜ ë‚˜ë¼ - í´ë˜ì‹ RPG </title>
                            <style>
                            * {
                            margin: 0;
                            padding: 0;
                            box- sizing: border - box;
      }
      body {
    overflow: hidden;
    background - color: #000;
}
</style>
    </head>
    < body >
    <div id="root" > </div>
        < script type = "module" src = "/src/main.tsx" > </script>
            </body>
            </html>
ğŸ“ src / main.tsx
React

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
    <StrictMode>
    <App />
    </StrictMode>,
)
ğŸ“ src / App.tsx
React

import { useEffect, useRef, useState, useCallback } from 'react';
import Phaser from 'phaser';
import { gameConfig } from './game/GameConfig';
import { GameEventBus } from './game/GameEventBus';
import HUD from './components/UI/HUD';
import Inventory from './components/UI/Inventory';
import DungeonSelector from './components/UI/DungeonSelector';
import SkillBar from './components/UI/SkillBar';
import QuestPanel from './components/UI/QuestPanel';
import CodeViewer from './components/UI/CodeViewer';

// íƒ€ì… ì •ì˜
interface PlayerStats {
    hp: number;
    maxHp: number;
    mp: number;
    maxMp: number;
    level: number;
    exp: number;
    expToNext: number;
    gold: number;
    attack: number;
    defense: number;
}

interface InventoryItem {
    id: string;
    name: string;
    type: 'weapon' | 'armor' | 'consumable' | 'material' | 'skillbook';
    icon: string;
    quantity: number;
    description: string;
    price: number;
    sellPrice?: number;
    effect?: {
        hp?: number;
        mp?: number;
        attack?: number;
        defense?: number;
    };
    requiredLevel?: number;
}

interface Skill {
    id: string;
    name: string;
    icon: string;
    damage: number;
    mpCost: number;
    cooldown: number;
    currentCooldown: number;
    requiredLevel: number;
    description: string;
}

interface QuickSlot {
    slot: number;
    item: InventoryItem | null;
}

interface ActiveBuff {
    id: string;
    name: string;
    icon: string;
    duration: number;
    remainingTime: number;
    effect: {
        attack?: number;
        defense?: number;
        speed?: number;
    };
}

interface Quest {
    id: string;
    title: string;
    description: string;
    type: 'daily' | 'main' | 'side';
    objectives: {
        type: string;
        target: string;
        current: number;
        required: number;
    }[];
    rewards: {
        exp?: number;
        gold?: number;
        items?: { id: string; quantity: number }[];
    };
    completed: boolean;
    claimed: boolean;
}

interface CombatStats {
    totalDamage: number;
    killCount: number;
    critCount: number;
    hitCount: number;
    startTime: number;
    dps: number;
}

interface MinimapData {
    playerX: number;
    playerY: number;
    worldWidth: number;
    worldHeight: number;
    monsters: { x: number; y: number; isBoss: boolean }[];
}

interface Pet {
    id: string;
    name: string;
    icon: string;
    rarity: 'common' | 'rare' | 'epic' | 'legendary';
    bonus: {
        goldBonus?: number;
        expBonus?: number;
        attackBonus?: number;
        hpRegen?: number;
        mpRegen?: number;
    };
    price: number;
    requiredLevel: number;
    owned: boolean;
    active: boolean;
}

interface Achievement {
    id: string;
    name: string;
    description: string;
    icon: string;
    category: 'combat' | 'growth' | 'wealth' | 'exploration';
    requirement: number;
    current: number;
    completed: boolean;
    claimed: boolean;
    reward: {
        gold?: number;
        exp?: number;
        title?: string;
    };
}

interface Title {
    id: string;
    name: string;
    description: string;
    color: string;
    bonus: {
        attack?: number;
        defense?: number;
        critRate?: number;
        expBonus?: number;
    };
    equipped: boolean;
    unlocked: boolean;
}

interface GameStats {
    totalKills: number;
    totalDamageDealt: number;
    totalGoldEarned: number;
    totalExpEarned: number;
    highestCombo: number;
    totalDeaths: number;
    playTime: number;
    dungeonsCleared: number;
    bossesKilled: number;
}

interface GameSettings {
    bgmVolume: number;
    sfxVolume: number;
    showDamageNumbers: boolean;
    showMinimap: boolean;
    autoLoot: boolean;
    screenShake: boolean;
}

function App() {
    const gameRef = useRef<Phaser.Game | null>(null);
    const [currentScene, setCurrentScene] = useState<string>('boot');
    const [playerStats, setPlayerStats] = useState<PlayerStats>({
        hp: 100,
        maxHp: 100,
        mp: 50,
        maxMp: 50,
        level: 1,
        exp: 0,
        expToNext: 100,
        gold: 1000,
        attack: 10,
        defense: 5,
    });
    const [inventory, setInventory] = useState<InventoryItem[]>([
        {
            id: 'hp_potion_1',
            name: 'ë™ë™ì£¼',
            type: 'consumable',
            icon: 'ğŸ¶',
            quantity: 10,
            description: 'HPë¥¼ 50 íšŒë³µí•©ë‹ˆë‹¤.',
            price: 50,
            sellPrice: 25,
            effect: { hp: 50 },
        },
        {
            id: 'mp_potion_1',
            name: 'ë§ˆë ¥ ë¬¼ì•½',
            type: 'consumable',
            icon: 'ğŸ’§',
            quantity: 5,
            description: 'MPë¥¼ 30 íšŒë³µí•©ë‹ˆë‹¤.',
            price: 80,
            sellPrice: 40,
            effect: { mp: 30 },
        },
    ]);
    const [skills, setSkills] = useState<Skill[]>([
        {
            id: 'slash',
            name: 'ì°¸ê²©',
            icon: 'âš”ï¸',
            damage: 25,
            mpCost: 5,
            cooldown: 1000,
            currentCooldown: 0,
            requiredLevel: 1,
            description: 'ê¸°ë³¸ ê²€ìˆ  ê³µê²©',
        },
        {
            id: 'fireball',
            name: 'í™”ì—¼êµ¬',
            icon: 'ğŸ”¥',
            damage: 50,
            mpCost: 15,
            cooldown: 3000,
            currentCooldown: 0,
            requiredLevel: 5,
            description: 'ê°•ë ¥í•œ í™”ì—¼ ë§ˆë²•',
        },
        {
            id: 'heal',
            name: 'ì¹˜ìœ ',
            icon: 'ğŸ’š',
            damage: 0,
            mpCost: 20,
            cooldown: 5000,
            currentCooldown: 0,
            requiredLevel: 3,
            description: 'HPë¥¼ 30 íšŒë³µ',
        },
        {
            id: 'thunder',
            name: 'ë‚™ë¢°',
            icon: 'âš¡',
            damage: 80,
            mpCost: 25,
            cooldown: 4000,
            currentCooldown: 0,
            requiredLevel: 10,
            description: 'ë²ˆê°œë¥¼ ì†Œí™˜í•˜ì—¬ ê³µê²©',
        },
        {
            id: 'ice_storm',
            name: 'ë¹™í’',
            icon: 'â„ï¸',
            damage: 60,
            mpCost: 20,
            cooldown: 3500,
            currentCooldown: 0,
            requiredLevel: 8,
            description: 'ì–¼ìŒ í­í’ìœ¼ë¡œ ë²”ìœ„ ê³µê²©',
        },
        {
            id: 'battle_cry',
            name: 'ì „íˆ¬í•¨ì„±',
            icon: 'ğŸ“¯',
            damage: 0,
            mpCost: 30,
            cooldown: 10000,
            currentCooldown: 0,
            requiredLevel: 15,
            description: '10ì´ˆê°„ ê³µê²©ë ¥ 50% ì¦ê°€',
        },
    ]);
    const [quickSlots, setQuickSlots] = useState<QuickSlot[]>([
        { slot: 0, item: null },
        { slot: 1, item: null },
        { slot: 2, item: null },
        { slot: 3, item: null },
        { slot: 4, item: null },
    ]);
    const [showInventory, setShowInventory] = useState(false);
    const [showDungeonSelector, setShowDungeonSelector] = useState(false);
    const [showSkillBar, setShowSkillBar] = useState(false);
    const [showQuestPanel, setShowQuestPanel] = useState(false);
    const [showCodeViewer, setShowCodeViewer] = useState(false);
    const [showSettings, setShowSettings] = useState(false);
    const [showAchievements, setShowAchievements] = useState(false);
    const [showPetShop, setShowPetShop] = useState(false);
    const [showStats, setShowStats] = useState(false);
    const [showDailyReward, setShowDailyReward] = useState(false);
    const [activeBuffs, setActiveBuffs] = useState<ActiveBuff[]>([]);
    const [isAutoAttack, setIsAutoAttack] = useState(false);
    const [combatStats, setCombatStats] = useState<CombatStats>({
        totalDamage: 0,
        killCount: 0,
        critCount: 0,
        hitCount: 0,
        startTime: Date.now(),
        dps: 0,
    });
    const [minimapData, setMinimapData] = useState<MinimapData | null>(null);
    const [quests, setQuests] = useState<Quest[]>([
        {
            id: 'daily_kill_50',
            title: 'ëª¬ìŠ¤í„° ì‚¬ëƒ¥ê¾¼',
            description: 'ëª¬ìŠ¤í„° 50ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'kill', target: 'any', current: 0, required: 50 }],
            rewards: { exp: 500, gold: 200 },
            completed: false,
            claimed: false,
        },
        {
            id: 'daily_kill_200',
            title: 'í•™ì‚´ì',
            description: 'ëª¬ìŠ¤í„° 200ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'kill', target: 'any', current: 0, required: 200 }],
            rewards: { exp: 2000, gold: 1000 },
            completed: false,
            claimed: false,
        },
        {
            id: 'daily_gold',
            title: 'ê³¨ë“œ ìˆ˜ì§‘ê°€',
            description: 'ê³¨ë“œë¥¼ 1000 íšë“í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'collect', target: 'gold', current: 0, required: 1000 }],
            rewards: { exp: 300, gold: 500 },
            completed: false,
            claimed: false,
        },
        {
            id: 'main_level_10',
            title: 'ì„±ì¥ì˜ ì‹œì‘',
            description: 'ë ˆë²¨ 10ì— ë„ë‹¬í•˜ì„¸ìš”',
            type: 'main',
            objectives: [{ type: 'level', target: 'player', current: 1, required: 10 }],
            rewards: { exp: 1000, gold: 500 },
            completed: false,
            claimed: false,
        },
        {
            id: 'main_level_50',
            title: 'ìˆ™ë ¨ìì˜ ê¸¸',
            description: 'ë ˆë²¨ 50ì— ë„ë‹¬í•˜ì„¸ìš”',
            type: 'main',
            objectives: [{ type: 'level', target: 'player', current: 1, required: 50 }],
            rewards: { exp: 10000, gold: 5000 },
            completed: false,
            claimed: false,
        },
    ]);

    // í« ì‹œìŠ¤í…œ
    const [pets, setPets] = useState<Pet[]>([
        { id: 'slime_pet', name: 'ìŠ¬ë¼ì„', icon: 'ğŸŸ¢', rarity: 'common', bonus: { goldBonus: 5 }, price: 500, requiredLevel: 1, owned: false, active: false },
        { id: 'fairy_pet', name: 'ìš”ì •', icon: 'ğŸ§š', rarity: 'common', bonus: { expBonus: 5 }, price: 800, requiredLevel: 5, owned: false, active: false },
        { id: 'cat_pet', name: 'ê³ ì–‘ì´', icon: 'ğŸ±', rarity: 'rare', bonus: { goldBonus: 10, expBonus: 5 }, price: 2000, requiredLevel: 10, owned: false, active: false },
        { id: 'owl_pet', name: 'ë¶€ì—‰ì´', icon: 'ğŸ¦‰', rarity: 'rare', bonus: { expBonus: 15 }, price: 3000, requiredLevel: 15, owned: false, active: false },
        { id: 'phoenix_baby', name: 'ë¶ˆì‚¬ì¡° ìƒˆë¼', icon: 'ğŸ¦â€ğŸ”¥', rarity: 'epic', bonus: { hpRegen: 2, mpRegen: 1 }, price: 5000, requiredLevel: 20, owned: false, active: false },
        { id: 'dragon_pet', name: 'ë“œë˜ê³¤', icon: 'ğŸ²', rarity: 'epic', bonus: { attackBonus: 10, goldBonus: 10 }, price: 10000, requiredLevel: 30, owned: false, active: false },
        { id: 'wolf_pet', name: 'ëŠ‘ëŒ€', icon: 'ğŸº', rarity: 'rare', bonus: { attackBonus: 5, expBonus: 5 }, price: 4000, requiredLevel: 25, owned: false, active: false },
        { id: 'golem_pet', name: 'ê³¨ë ˜', icon: 'ğŸ—¿', rarity: 'epic', bonus: { attackBonus: 15 }, price: 8000, requiredLevel: 35, owned: false, active: false },
        { id: 'phoenix_pet', name: 'ë¶ˆì‚¬ì¡°', icon: 'ğŸ”¥', rarity: 'legendary', bonus: { hpRegen: 5, mpRegen: 3, expBonus: 20 }, price: 50000, requiredLevel: 50, owned: false, active: false },
        { id: 'unicorn_pet', name: 'ìœ ë‹ˆì½˜', icon: 'ğŸ¦„', rarity: 'legendary', bonus: { goldBonus: 30, expBonus: 30, attackBonus: 20 }, price: 100000, requiredLevel: 70, owned: false, active: false },
    ]);

    // ì—…ì  ì‹œìŠ¤í…œ
    const [achievements, setAchievements] = useState<Achievement[]>([
        { id: 'kill_100', name: 'ì´ˆë³´ ì‚¬ëƒ¥ê¾¼', description: 'ëª¬ìŠ¤í„° 100ë§ˆë¦¬ ì²˜ì¹˜', icon: 'ğŸ—¡ï¸', category: 'combat', requirement: 100, current: 0, completed: false, claimed: false, reward: { gold: 500, title: 'novice_hunter' } },
        { id: 'kill_1000', name: 'ìˆ™ë ¨ëœ ì‚¬ëƒ¥ê¾¼', description: 'ëª¬ìŠ¤í„° 1000ë§ˆë¦¬ ì²˜ì¹˜', icon: 'âš”ï¸', category: 'combat', requirement: 1000, current: 0, completed: false, claimed: false, reward: { gold: 2000, title: 'skilled_hunter' } },
        { id: 'kill_10000', name: 'ì „ì„¤ì˜ ì‚¬ëƒ¥ê¾¼', description: 'ëª¬ìŠ¤í„° 10000ë§ˆë¦¬ ì²˜ì¹˜', icon: 'ğŸ†', category: 'combat', requirement: 10000, current: 0, completed: false, claimed: false, reward: { gold: 10000, title: 'legendary_hunter' } },
        { id: 'damage_10000', name: 'íŒŒê´´ì', description: 'ëˆ„ì  ë°ë¯¸ì§€ 10000', icon: 'ğŸ’¥', category: 'combat', requirement: 10000, current: 0, completed: false, claimed: false, reward: { gold: 1000 } },
        { id: 'damage_100000', name: 'ëŒ€íŒŒê´´ì', description: 'ëˆ„ì  ë°ë¯¸ì§€ 100000', icon: 'ğŸ”¥', category: 'combat', requirement: 100000, current: 0, completed: false, claimed: false, reward: { gold: 5000, title: 'destroyer' } },
        { id: 'level_10', name: 'ì„±ì¥ ì¤‘', description: 'ë ˆë²¨ 10 ë‹¬ì„±', icon: 'ğŸ“ˆ', category: 'growth', requirement: 10, current: 1, completed: false, claimed: false, reward: { gold: 300 } },
        { id: 'level_30', name: 'ì¤‘ê¸‰ ëª¨í—˜ê°€', description: 'ë ˆë²¨ 30 ë‹¬ì„±', icon: 'â­', category: 'growth', requirement: 30, current: 1, completed: false, claimed: false, reward: { gold: 1000, title: 'adventurer' } },
        { id: 'level_50', name: 'ìƒê¸‰ ëª¨í—˜ê°€', description: 'ë ˆë²¨ 50 ë‹¬ì„±', icon: 'ğŸŒŸ', category: 'growth', requirement: 50, current: 1, completed: false, claimed: false, reward: { gold: 3000, title: 'elite_adventurer' } },
        { id: 'level_100', name: 'ì˜ì›…', description: 'ë ˆë²¨ 100 ë‹¬ì„±', icon: 'ğŸ‘‘', category: 'growth', requirement: 100, current: 1, completed: false, claimed: false, reward: { gold: 10000, title: 'hero' } },
        { id: 'gold_10000', name: 'ë¶€ì', description: 'ê³¨ë“œ 10000 ë³´ìœ ', icon: 'ğŸ’°', category: 'wealth', requirement: 10000, current: 0, completed: false, claimed: false, reward: { exp: 1000 } },
        { id: 'gold_100000', name: 'ëŒ€ë¶€í˜¸', description: 'ê³¨ë“œ 100000 ë³´ìœ ', icon: 'ğŸ’', category: 'wealth', requirement: 100000, current: 0, completed: false, claimed: false, reward: { exp: 5000, title: 'tycoon' } },
        { id: 'combo_50', name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', description: '50 ì½¤ë³´ ë‹¬ì„±', icon: 'ğŸ”—', category: 'combat', requirement: 50, current: 0, completed: false, claimed: false, reward: { gold: 1000 } },
        { id: 'combo_100', name: 'ì½¤ë³´ ë ˆì „ë“œ', description: '100 ì½¤ë³´ ë‹¬ì„±', icon: 'â›“ï¸', category: 'combat', requirement: 100, current: 0, completed: false, claimed: false, reward: { gold: 3000, title: 'combo_master' } },
        { id: 'kill_500', name: 'ë² í…Œë‘', description: 'ëª¬ìŠ¤í„° 500ë§ˆë¦¬ ì²˜ì¹˜', icon: 'ğŸ–ï¸', category: 'combat', requirement: 500, current: 0, completed: false, claimed: false, reward: { gold: 1000 } },
        { id: 'kill_5000', name: 'í•™ì‚´ì', description: 'ëª¬ìŠ¤í„° 5000ë§ˆë¦¬ ì²˜ì¹˜', icon: 'â˜ ï¸', category: 'combat', requirement: 5000, current: 0, completed: false, claimed: false, reward: { gold: 5000, title: 'slayer' } },
        { id: 'level_20', name: 'ê²¬ìŠµ ì „ì‚¬', description: 'ë ˆë²¨ 20 ë‹¬ì„±', icon: 'ğŸ›¡ï¸', category: 'growth', requirement: 20, current: 1, completed: false, claimed: false, reward: { gold: 500 } },
        { id: 'level_70', name: 'ë§ˆìŠ¤í„°', description: 'ë ˆë²¨ 70 ë‹¬ì„±', icon: 'ğŸ¯', category: 'growth', requirement: 70, current: 1, completed: false, claimed: false, reward: { gold: 5000, title: 'master' } },
        { id: 'gold_50000', name: 'ì¬ë²Œ', description: 'ê³¨ë“œ 50000 ë³´ìœ ', icon: 'ğŸ¦', category: 'wealth', requirement: 50000, current: 0, completed: false, claimed: false, reward: { exp: 3000 } },
    ]);

    // ì¹­í˜¸ ì‹œìŠ¤í…œ
    const [titles, setTitles] = useState<Title[]>([
        { id: 'novice', name: 'ì´ˆë³´ ëª¨í—˜ê°€', description: 'ì—¬ì •ì„ ì‹œì‘í•œ ì', color: '#aaaaaa', bonus: {}, equipped: true, unlocked: true },
        { id: 'novice_hunter', name: 'ì´ˆë³´ ì‚¬ëƒ¥ê¾¼', description: '100ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•œ ì', color: '#55ff55', bonus: { attack: 2 }, equipped: false, unlocked: false },
        { id: 'skilled_hunter', name: 'ìˆ™ë ¨ëœ ì‚¬ëƒ¥ê¾¼', description: '1000ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•œ ì', color: '#5555ff', bonus: { attack: 5, critRate: 2 }, equipped: false, unlocked: false },
        { id: 'legendary_hunter', name: 'ì „ì„¤ì˜ ì‚¬ëƒ¥ê¾¼', description: '10000ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•œ ì', color: '#ff55ff', bonus: { attack: 15, critRate: 5 }, equipped: false, unlocked: false },
        { id: 'destroyer', name: 'íŒŒê´´ì', description: 'ì—„ì²­ë‚œ ë°ë¯¸ì§€ë¥¼ ì¤€ ì', color: '#ff5555', bonus: { attack: 10 }, equipped: false, unlocked: false },
        { id: 'adventurer', name: 'ëª¨í—˜ê°€', description: 'ë ˆë²¨ 30ì„ ë‹¬ì„±í•œ ì', color: '#55ffff', bonus: { expBonus: 5 }, equipped: false, unlocked: false },
        { id: 'elite_adventurer', name: 'ì •ì˜ˆ ëª¨í—˜ê°€', description: 'ë ˆë²¨ 50ì„ ë‹¬ì„±í•œ ì', color: '#ffff55', bonus: { expBonus: 10, attack: 5 }, equipped: false, unlocked: false },
        { id: 'hero', name: 'ì˜ì›…', description: 'ë ˆë²¨ 100ì„ ë‹¬ì„±í•œ ì', color: '#ff8800', bonus: { expBonus: 15, attack: 10, defense: 5 }, equipped: false, unlocked: false },
        { id: 'tycoon', name: 'ëŒ€ë¶€í˜¸', description: 'ë§‰ëŒ€í•œ ë¶€ë¥¼ ì¶•ì í•œ ì', color: '#ffdd00', bonus: { expBonus: 10 }, equipped: false, unlocked: false },
        { id: 'combo_master', name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', description: '100 ì½¤ë³´ë¥¼ ë‹¬ì„±í•œ ì', color: '#dd00ff', bonus: { attack: 8, critRate: 3 }, equipped: false, unlocked: false },
        { id: 'slayer', name: 'í•™ì‚´ì', description: '5000ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•œ ì', color: '#880000', bonus: { attack: 12, critRate: 4 }, equipped: false, unlocked: false },
        { id: 'master', name: 'ë§ˆìŠ¤í„°', description: 'ë ˆë²¨ 70ì„ ë‹¬ì„±í•œ ì', color: '#00ffaa', bonus: { expBonus: 12, attack: 8 }, equipped: false, unlocked: false },
    ]);

    // ê²Œì„ í†µê³„
    const [gameStats, setGameStats] = useState<GameStats>({
        totalKills: 0,
        totalDamageDealt: 0,
        totalGoldEarned: 0,
        totalExpEarned: 0,
        highestCombo: 0,
        totalDeaths: 0,
        playTime: 0,
        dungeonsCleared: 0,
        bossesKilled: 0,
    });

    // ê²Œì„ ì„¤ì •
    const [settings, setSettings] = useState<GameSettings>({
        bgmVolume: 70,
        sfxVolume: 80,
        showDamageNumbers: true,
        showMinimap: true,
        autoLoot: true,
        screenShake: true,
    });

    // ì¼ì¼ ë³´ìƒ ì‹œìŠ¤í…œ
    const [dailyReward, setDailyReward] = useState({
        lastClaimed: '',
        streak: 0,
        canClaim: true,
    });

    // ë ˆë²¨ì—… ì•Œë¦¼
    const [levelUpNotification, setLevelUpNotification] = useState<{ show: boolean; level: number }>({ show: false, level: 0 });

    // ê²Œì„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    const handlePlayerUpdate = useCallback((stats: PlayerStats) => {
        // ë ˆë²¨ì—… ì²´í¬
        if (stats.level > playerStats.level) {
            setLevelUpNotification({ show: true, level: stats.level });
            setTimeout(() => setLevelUpNotification({ show: false, level: 0 }), 3000);
        }

        setPlayerStats(stats);
        // ë ˆë²¨ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        setQuests(prev => prev.map(quest => {
            if (quest.objectives[0].type === 'level') {
                const newCurrent = stats.level;
                const completed = newCurrent >= quest.objectives[0].required;
                return {
                    ...quest,
                    objectives: [{ ...quest.objectives[0], current: newCurrent }],
                    completed,
                };
            }
            return quest;
        }));
        // ì—…ì  ì—…ë°ì´íŠ¸
        setAchievements(prev => prev.map(ach => {
            if (ach.category === 'growth' && ach.id.startsWith('level_')) {
                const newCurrent = stats.level;
                return { ...ach, current: newCurrent, completed: newCurrent >= ach.requirement };
            }
            if (ach.category === 'wealth' && ach.id.startsWith('gold_')) {
                return { ...ach, current: stats.gold, completed: stats.gold >= ach.requirement };
            }
            return ach;
        }));
    }, [playerStats.level]);

    const handleAddItem = useCallback((item: InventoryItem) => {
        setInventory((prev) => {
            const existing = prev.find((i) => i.id === item.id);
            if (existing) {
                return prev.map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity + item.quantity } : i
                );
            }
            return [...prev, item];
        });
    }, []);

    const handleGoldChange = useCallback((amount: number) => {
        setPlayerStats((prev) => {
            const newGold = prev.gold + amount;
            // ê³¨ë“œ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            if (amount > 0) {
                setQuests(prevQuests => prevQuests.map(quest => {
                    if (quest.objectives[0].type === 'collect' && quest.objectives[0].target === 'gold') {
                        const newCurrent = Math.min(quest.objectives[0].current + amount, quest.objectives[0].required);
                        return {
                            ...quest,
                            objectives: [{ ...quest.objectives[0], current: newCurrent }],
                            completed: newCurrent >= quest.objectives[0].required,
                        };
                    }
                    return quest;
                }));
                setGameStats(prev => ({ ...prev, totalGoldEarned: prev.totalGoldEarned + amount }));
            }
            return { ...prev, gold: newGold };
        });
    }, []);

    const handleMonsterKilled = useCallback(() => {
        setQuests(prev => prev.map(quest => {
            if (quest.objectives[0].type === 'kill') {
                const newCurrent = Math.min(quest.objectives[0].current + 1, quest.objectives[0].required);
                return {
                    ...quest,
                    objectives: [{ ...quest.objectives[0], current: newCurrent }],
                    completed: newCurrent >= quest.objectives[0].required,
                };
            }
            return quest;
        }));
        setGameStats(prev => {
            const newKills = prev.totalKills + 1;
            // ì—…ì  ì—…ë°ì´íŠ¸
            setAchievements(prevAch => prevAch.map(ach => {
                if (ach.id.startsWith('kill_')) {
                    return { ...ach, current: newKills, completed: newKills >= ach.requirement };
                }
                return ach;
            }));
            return { ...prev, totalKills: newKills };
        });
    }, []);

    const handleCombatStatsUpdate = useCallback((stats: CombatStats) => {
        setCombatStats(stats);
        setGameStats(prev => ({
            ...prev,
            totalDamageDealt: prev.totalDamageDealt + (stats.totalDamage - prev.totalDamageDealt),
        }));
    }, []);

    const handleMinimapUpdate = useCallback((data: MinimapData) => {
        setMinimapData(data);
    }, []);

    const handleAutoAttackToggle = useCallback((enabled: boolean) => {
        setIsAutoAttack(enabled);
    }, []);

    const handleAddBuff = useCallback((buff: ActiveBuff) => {
        setActiveBuffs(prev => {
            const existing = prev.find(b => b.id === buff.id);
            if (existing) {
                return prev.map(b => b.id === buff.id ? buff : b);
            }
            return [...prev, buff];
        });
    }, []);

    const handleComboUpdate = useCallback((combo: number) => {
        setGameStats(prev => ({
            ...prev,
            highestCombo: Math.max(prev.highestCombo, combo),
        }));
        setAchievements(prev => prev.map(ach => {
            if (ach.id.startsWith('combo_')) {
                return { ...ach, current: Math.max(ach.current, combo), completed: combo >= ach.requirement };
            }
            return ach;
        }));
    }, []);

    // í€˜ìŠ¤íŠ¸ ë³´ìƒ ìˆ˜ë ¹
    const handleClaimQuest = useCallback((questId: string) => {
        const quest = quests.find(q => q.id === questId);
        if (quest && quest.completed && !quest.claimed) {
            // ë³´ìƒ ì§€ê¸‰
            if (quest.rewards.exp) {
                setPlayerStats(prev => ({
                    ...prev,
                    exp: prev.exp + quest.rewards.exp!,
                }));
            }
            if (quest.rewards.gold) {
                setPlayerStats(prev => ({
                    ...prev,
                    gold: prev.gold + quest.rewards.gold!,
                }));
            }
            // í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì²˜ë¦¬
            setQuests(prev => prev.map(q =>
                q.id === questId ? { ...q, claimed: true } : q
            ));
        }
    }, [quests]);

    // ì•„ì´í…œ íŒë§¤
    const handleSellItem = useCallback((itemId: string, quantity: number = 1) => {
        const item = inventory.find(i => i.id === itemId);
        if (!item) return;

        const sellPrice = (item.sellPrice || Math.floor(item.price / 2)) * quantity;

        setInventory(prev => {
            const updated = prev.map(i => {
                if (i.id === itemId) {
                    return { ...i, quantity: i.quantity - quantity };
                }
                return i;
            }).filter(i => i.quantity > 0);
            return updated;
        });

        setPlayerStats(prev => ({
            ...prev,
            gold: prev.gold + sellPrice,
        }));

        // í€µìŠ¬ë¡¯ì—ì„œë„ ì œê±°
        setQuickSlots(prev => prev.map(slot => {
            if (slot.item?.id === itemId) {
                const remaining = inventory.find(i => i.id === itemId);
                if (!remaining || remaining.quantity <= quantity) {
                    return { ...slot, item: null };
                }
            }
            return slot;
        }));
    }, [inventory]);

    // í« êµ¬ë§¤
    const handleBuyPet = useCallback((petId: string) => {
        const pet = pets.find(p => p.id === petId);
        if (!pet || pet.owned || playerStats.gold < pet.price || playerStats.level < pet.requiredLevel) return;

        setPlayerStats(prev => ({ ...prev, gold: prev.gold - pet.price }));
        setPets(prev => prev.map(p => p.id === petId ? { ...p, owned: true } : p));
    }, [pets, playerStats]);

    // í« í™œì„±í™”
    const handleActivatePet = useCallback((petId: string) => {
        setPets(prev => prev.map(p => ({
            ...p,
            active: p.id === petId && p.owned,
        })));
    }, []);

    // ì—…ì  ë³´ìƒ ìˆ˜ë ¹
    const handleClaimAchievement = useCallback((achId: string) => {
        const ach = achievements.find(a => a.id === achId);
        if (!ach || !ach.completed || ach.claimed) return;

        if (ach.reward.gold) {
            setPlayerStats(prev => ({ ...prev, gold: prev.gold + ach.reward.gold! }));
        }
        if (ach.reward.exp) {
            setPlayerStats(prev => ({ ...prev, exp: prev.exp + ach.reward.exp! }));
        }
        if (ach.reward.title) {
            setTitles(prev => prev.map(t => t.id === ach.reward.title ? { ...t, unlocked: true } : t));
        }
        setAchievements(prev => prev.map(a => a.id === achId ? { ...a, claimed: true } : a));
    }, [achievements]);

    // ì¹­í˜¸ ì¥ì°©
    const handleEquipTitle = useCallback((titleId: string) => {
        setTitles(prev => prev.map(t => ({
            ...t,
            equipped: t.id === titleId && t.unlocked,
        })));
    }, []);

    // ì¼ì¼ ë³´ìƒ ìˆ˜ë ¹
    const handleClaimDailyReward = useCallback(() => {
        const today = new Date().toDateString();
        if (dailyReward.lastClaimed === today) return;

        const baseGold = 100 * (1 + dailyReward.streak * 0.1);
        const baseExp = 50 * (1 + dailyReward.streak * 0.1);

        setPlayerStats(prev => ({
            ...prev,
            gold: prev.gold + Math.floor(baseGold),
            exp: prev.exp + Math.floor(baseExp),
        }));

        setDailyReward(prev => ({
            lastClaimed: today,
            streak: prev.lastClaimed === new Date(Date.now() - 86400000).toDateString() ? prev.streak + 1 : 1,
            canClaim: false,
        }));

        setShowDailyReward(false);
    }, [dailyReward]);

    // ì„¸ì´ë¸Œ/ë¡œë“œ ì‹œìŠ¤í…œ
    const saveGame = useCallback(() => {
        const saveData = {
            playerStats,
            inventory,
            skills,
            quickSlots,
            pets,
            achievements,
            titles,
            gameStats,
            settings,
            dailyReward,
            quests,
        };
        localStorage.setItem('windKingdomSave', JSON.stringify(saveData));
    }, [playerStats, inventory, skills, quickSlots, pets, achievements, titles, gameStats, settings, dailyReward, quests]);

    const loadGame = useCallback(() => {
        const saved = localStorage.getItem('windKingdomSave');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.playerStats) setPlayerStats(data.playerStats);
                if (data.inventory) setInventory(data.inventory);
                if (data.skills) setSkills(data.skills);
                if (data.quickSlots) setQuickSlots(data.quickSlots);
                if (data.pets) setPets(data.pets);
                if (data.achievements) setAchievements(data.achievements);
                if (data.titles) setTitles(data.titles);
                if (data.gameStats) setGameStats(data.gameStats);
                if (data.settings) setSettings(data.settings);
                if (data.dailyReward) setDailyReward(data.dailyReward);
                if (data.quests) setQuests(data.quests);
            } catch (e) {
                console.error('Failed to load save:', e);
            }
        }
    }, []);

    // ìë™ ì €ì¥
    useEffect(() => {
        const interval = setInterval(saveGame, 60000);
        return () => clearInterval(interval);
    }, [saveGame]);

    // ê²Œì„ ë¡œë“œ
    useEffect(() => {
        loadGame();
        // ì¼ì¼ ë³´ìƒ ì²´í¬
        const today = new Date().toDateString();
        setDailyReward(prev => ({
            ...prev,
            canClaim: prev.lastClaimed !== today,
        }));
    }, [loadGame]);

    // ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸
    useEffect(() => {
        const interval = setInterval(() => {
            setSkills((prev) =>
                prev.map((skill) => ({
                    ...skill,
                    currentCooldown: Math.max(0, skill.currentCooldown - 100),
                }))
            );
            // ë²„í”„ ì‹œê°„ ì—…ë°ì´íŠ¸
            setActiveBuffs(prev =>
                prev
                    .map(buff => ({ ...buff, remainingTime: buff.remainingTime - 0.1 }))
                    .filter(buff => buff.remainingTime > 0)
            );
            // í« íš¨ê³¼ ì ìš©
            const activePet = pets.find(p => p.active);
            if (activePet) {
                if (activePet.bonus.hpRegen) {
                    setPlayerStats(prev => ({
                        ...prev,
                        hp: Math.min(prev.maxHp, prev.hp + activePet.bonus.hpRegen! * 0.1),
                    }));
                }
                if (activePet.bonus.mpRegen) {
                    setPlayerStats(prev => ({
                        ...prev,
                        mp: Math.min(prev.maxMp, prev.mp + activePet.bonus.mpRegen! * 0.1),
                    }));
                }
            }
        }, 100);
        return () => clearInterval(interval);
    }, [pets]);

    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ - ESCë¡œ ëª¨ë“  ì°½ ë‹«ê¸°
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // ESC í‚¤ ì²˜ë¦¬ - ì—´ë¦° ëª¨ë‹¬ì„ ìˆœì„œëŒ€ë¡œ ë‹«ìŒ (ë’¤ë¡œê°€ê¸°)
            if (e.key === 'Escape') {
                if (showDailyReward) {
                    setShowDailyReward(false);
                    return;
                }
                if (showInventory) {
                    setShowInventory(false);
                    return;
                }
                if (showSkillBar) {
                    setShowSkillBar(false);
                    return;
                }
                if (showQuestPanel) {
                    setShowQuestPanel(false);
                    return;
                }
                if (showSettings) {
                    setShowSettings(false);
                    return;
                }
                if (showAchievements) {
                    setShowAchievements(false);
                    return;
                }
                if (showPetShop) {
                    setShowPetShop(false);
                    return;
                }
                if (showStats) {
                    setShowStats(false);
                    return;
                }
                if (showCodeViewer) {
                    setShowCodeViewer(false);
                    return;
                }
                // ì•„ë¬´ ì°½ë„ ì—†ìœ¼ë©´ ë˜ì „ ì…€ë ‰í„° í† ê¸€
                setShowDungeonSelector(prev => !prev);
                return;
            }

            if (e.key.toLowerCase() === 'i') {
                setShowInventory((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'w' && !e.ctrlKey) {
                setShowSkillBar((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'j') {
                setShowQuestPanel((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'o') {
                setShowSettings((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'p') {
                setShowAchievements((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'l') {
                setShowPetShop((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'k') {
                setShowStats((prev) => !prev);
            }

            // í€µìŠ¬ë¡¯ ì‚¬ìš©
            const quickSlotKeys = ['q', 'e', 'r', 't', 'f'];
            const keyIndex = quickSlotKeys.indexOf(e.key.toLowerCase());
            if (keyIndex !== -1) {
                const slot = quickSlots[keyIndex];
                if (slot.item && slot.item.type === 'consumable') {
                    useQuickSlotItem(keyIndex);
                }
            }

            // ìŠ¤í‚¬ ì‚¬ìš© (1-9)
            const skillIndex = parseInt(e.key) - 1;
            if (skillIndex >= 0 && skillIndex < skills.length) {
                useSkill(skillIndex);
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [quickSlots, skills, showInventory, showDungeonSelector, showSkillBar, showQuestPanel, showCodeViewer, showSettings, showAchievements, showPetShop, showStats, showDailyReward]);

    // ìŠ¤í‚¬ ì‚¬ìš©
    const useSkill = (index: number) => {
        const skill = skills[index];
        if (!skill) return;
        if (skill.currentCooldown > 0) return;
        if (playerStats.mp < skill.mpCost) return;
        if (playerStats.level < skill.requiredLevel) return;

        // MP ì†Œëª¨
        setPlayerStats((prev) => ({
            ...prev,
            mp: prev.mp - skill.mpCost,
        }));

        // ì¿¨ë‹¤ìš´ ì‹œì‘
        setSkills((prev) =>
            prev.map((s, i) =>
                i === index ? { ...s, currentCooldown: s.cooldown } : s
            )
        );

        // í ìŠ¤í‚¬ ì²˜ë¦¬
        if (skill.id === 'heal') {
            setPlayerStats((prev) => ({
                ...prev,
                hp: Math.min(prev.maxHp, prev.hp + 30),
            }));
        }

        // ë²„í”„ ìŠ¤í‚¬ ì²˜ë¦¬
        if (skill.id === 'battle_cry') {
            const buff: ActiveBuff = {
                id: 'battle_cry_buff',
                name: 'ì „íˆ¬í•¨ì„±',
                icon: 'ğŸ“¯',
                duration: 10,
                remainingTime: 10,
                effect: { attack: 50 },
            };
            handleAddBuff(buff);
            GameEventBus.emit('ADD_BUFF', buff);
        }

        // ê²Œì„ì— ìŠ¤í‚¬ ì´ë²¤íŠ¸ ì „ë‹¬
        GameEventBus.emit('USE_SKILL', skill);
    };

    // í€µìŠ¬ë¡¯ ì•„ì´í…œ ì‚¬ìš©
    const useQuickSlotItem = (slotIndex: number) => {
        const slot = quickSlots[slotIndex];
        if (!slot.item) return;

        const item = slot.item;
        if (item.effect) {
            setPlayerStats((prev) => ({
                ...prev,
                hp: Math.min(prev.maxHp, prev.hp + (item.effect?.hp || 0)),
                mp: Math.min(prev.maxMp, prev.mp + (item.effect?.mp || 0)),
            }));
        }

        // ì¸ë²¤í† ë¦¬ì—ì„œ ìˆ˜ëŸ‰ ê°ì†Œ
        setInventory((prev) =>
            prev
                .map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i
                )
                .filter((i) => i.quantity > 0)
        );

        // í€µìŠ¬ë¡¯ ì—…ë°ì´íŠ¸
        setQuickSlots((prev) =>
            prev.map((s, i) => {
                if (i === slotIndex) {
                    const remainingItem = inventory.find(
                        (inv) => inv.id === item.id && inv.quantity > 1
                    );
                    return { ...s, item: remainingItem || null };
                }
                return s;
            })
        );
    };

    // í€µìŠ¬ë¡¯ì— ì•„ì´í…œ ë“±ë¡
    const assignToQuickSlot = (slotIndex: number, item: InventoryItem) => {
        setQuickSlots((prev) =>
            prev.map((s, i) => (i === slotIndex ? { ...s, item } : s))
        );
    };

    // ë˜ì „ ì„ íƒ
    const handleSelectDungeon = (dungeonLevel: number) => {
        setShowDungeonSelector(false);
        setCombatStats({
            totalDamage: 0,
            killCount: 0,
            critCount: 0,
            hitCount: 0,
            startTime: Date.now(),
            dps: 0,
        });
        GameEventBus.emit('CHANGE_SCENE', {
            scene: 'DungeonScene',
            data: { dungeonLevel },
        });
        setCurrentScene('dungeon');
    };

    // ë§ˆì„ë¡œ ê·€í™˜
    const handleReturnToTown = () => {
        setShowDungeonSelector(false);
        setMinimapData(null);
        GameEventBus.emit('CHANGE_SCENE', { scene: 'TownScene' });
        setCurrentScene('town');
    };

    // Phaser ê²Œì„ ì´ˆê¸°í™”
    useEffect(() => {
        if (gameRef.current) return;

        gameRef.current = new Phaser.Game(gameConfig);

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        GameEventBus.on('PLAYER_UPDATE', handlePlayerUpdate);
        GameEventBus.on('ADD_ITEM', handleAddItem);
        GameEventBus.on('GOLD_CHANGE', handleGoldChange);
        GameEventBus.on('MONSTER_KILLED', handleMonsterKilled);
        GameEventBus.on('COMBAT_STATS_UPDATE', handleCombatStatsUpdate);
        GameEventBus.on('MINIMAP_UPDATE', handleMinimapUpdate);
        GameEventBus.on('AUTO_ATTACK_TOGGLE', handleAutoAttackToggle);
        GameEventBus.on('ADD_BUFF', handleAddBuff);
        GameEventBus.on('COMBO_UPDATE', handleComboUpdate);
        GameEventBus.on('SCENE_CHANGED', (scene: string) => setCurrentScene(scene));
        GameEventBus.on('TOGGLE_DUNGEON_MENU', () => setShowDungeonSelector(prev => !prev));
        GameEventBus.on('TOGGLE_INVENTORY', () => setShowInventory(prev => !prev));
        GameEventBus.on('TOGGLE_SKILL_MENU', () => setShowSkillBar(prev => !prev));
        GameEventBus.on('TOGGLE_QUEST_PANEL', () => setShowQuestPanel(prev => !prev));

        return () => {
            GameEventBus.off('PLAYER_UPDATE', handlePlayerUpdate);
            GameEventBus.off('ADD_ITEM', handleAddItem);
            GameEventBus.off('GOLD_CHANGE', handleGoldChange);
            GameEventBus.off('MONSTER_KILLED', handleMonsterKilled);
            GameEventBus.off('COMBAT_STATS_UPDATE', handleCombatStatsUpdate);
            GameEventBus.off('MINIMAP_UPDATE', handleMinimapUpdate);
            GameEventBus.off('AUTO_ATTACK_TOGGLE', handleAutoAttackToggle);
            GameEventBus.off('ADD_BUFF', handleAddBuff);
            GameEventBus.off('COMBO_UPDATE', handleComboUpdate);
            gameRef.current?.destroy(true);
            gameRef.current = null;
        };
    }, [handlePlayerUpdate, handleAddItem, handleGoldChange, handleMonsterKilled, handleCombatStatsUpdate, handleMinimapUpdate, handleAutoAttackToggle, handleAddBuff, handleComboUpdate]);

    const activePet = pets.find(p => p.active);
    const equippedTitle = titles.find(t => t.equipped);

    return (
        <div className= "relative w-screen h-screen overflow-hidden bg-black" >
        {/* Phaser ê²Œì„ ì»¨í…Œì´ë„ˆ */ }
        < div id = "game-container" className = "absolute inset-0" />

            {/* React UI ì˜¤ë²„ë ˆì´ */ }
            < HUD
    playerStats = { playerStats }
    quickSlots = { quickSlots }
    skills = { skills }
    currentScene = { currentScene }
    activeBuffs = { activeBuffs }
    isAutoAttack = { isAutoAttack }
    combatStats = { currentScene === 'dungeon' ? combatStats : undefined
}
minimapData = { currentScene === 'dungeon' ? minimapData : undefined}
activePet = { activePet }
equippedTitle = { equippedTitle }
    />

    {/* ë ˆë²¨ì—… ì•Œë¦¼ - ìš°ì¸¡ í•˜ë‹¨ */ }
{
    levelUpNotification.show && (
        <div className="fixed bottom-24 right-4 z-50 animate-bounce" >
            <div className="bg-gradient-to-r from-yellow-600 to-yellow-400 text-black px-6 py-3 rounded-lg shadow-lg border-2 border-yellow-300" >
                <div className="flex items-center gap-2" >
                    <span className="text-2xl" >ğŸ‰</span>
                        < div >
                        <div className="font-bold text-lg" > ë ˆë²¨ ì—…! </div>
                            < div className = "text-sm" > Lv.{ levelUpNotification.level } ë‹¬ì„±! </div>
                                </div>
                                </div>
                                </div>
                                </div>
      )
}

{/* ë¹ ë¥¸ ì ‘ê·¼ ë²„íŠ¼ */ }
<div className="fixed top-4 right-4 flex gap-2 z-40" >
{
    dailyReward.canClaim && (
        <button
            onClick={ () => setShowDailyReward(true) }
className = "px-3 py-2 bg-yellow-600 hover:bg-yellow-500 text-white rounded-lg animate-pulse"
    >
            ğŸ
</button>
        )}
<button
          onClick={ () => setShowSettings(true) }
className = "px-3 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg"
    >
          âš™ï¸
</button>
    < button
onClick = {() => setShowAchievements(true)}
className = "px-3 py-2 bg-purple-700 hover:bg-purple-600 text-white rounded-lg"
    >
          ğŸ†
</button>
    < button
onClick = {() => setShowPetShop(true)}
className = "px-3 py-2 bg-green-700 hover:bg-green-600 text-white rounded-lg"
    >
          ğŸ¾
</button>
    < button
onClick = {() => setShowStats(true)}
className = "px-3 py-2 bg-blue-700 hover:bg-blue-600 text-white rounded-lg"
    >
          ğŸ“Š
</button>
    </div>

{/* ì¸ë²¤í† ë¦¬ */ }
{
    showInventory && (
        <Inventory
          items={ inventory }
    onClose = {() => setShowInventory(false)
}
onUseItem = {(item) => {
    if (item.type === 'consumable' && item.effect) {
        setPlayerStats((prev) => ({
            ...prev,
            hp: Math.min(prev.maxHp, prev.hp + (item.effect?.hp || 0)),
            mp: Math.min(prev.maxMp, prev.mp + (item.effect?.mp || 0)),
        }));
        setInventory((prev) =>
            prev
                .map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i
                )
                .filter((i) => i.quantity > 0)
        );
    }
}}
onAssignQuickSlot = { assignToQuickSlot }
onSellItem = { handleSellItem }
gold = { playerStats.gold }
    />
      )}

{/* ìŠ¤í‚¬ ë°” */ }
{
    showSkillBar && (
        <SkillBar
          skills={ skills }
    playerLevel = { playerStats.level }
    playerMp = { playerStats.mp }
    onClose = {() => setShowSkillBar(false)
}
onUseSkill = { useSkill }
    />
      )}

{/* ë˜ì „ ì„ íƒ */ }
{
    showDungeonSelector && (
        <DungeonSelector
          playerLevel={ playerStats.level }
    onSelect = { handleSelectDungeon }
    onClose = {() => setShowDungeonSelector(false)
}
onReturnToTown = { currentScene === 'dungeon' ? handleReturnToTown : undefined}
        />
      )}

{/* í€˜ìŠ¤íŠ¸ íŒ¨ë„ */ }
{
    showQuestPanel && (
        <QuestPanel
          quests={ quests }
    onClose = {() => setShowQuestPanel(false)
}
onClaimReward = { handleClaimQuest }
    />
      )}

{/* ì„¤ì • ì°½ */ }
{
    showSettings && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" >
            <div className="bg-gray-900 border-2 border-gray-600 rounded-lg p-6 w-96" >
                <div className="flex justify-between items-center mb-4" >
                    <h2 className="text-xl font-bold text-white" >âš™ï¸ ì„¤ì • </h2>
                        < button onClick = {() => setShowSettings(false)
} className = "text-gray-400 hover:text-white text-2xl" >& times; </button>
    </div>
    < div className = "space-y-4" >
        <div>
        <label className="text-gray-300 text-sm" > ë°°ê²½ ìŒì•… </label>
            < input
type = "range"
min = "0"
max = "100"
value = { settings.bgmVolume }
onChange = {(e) => setSettings(prev => ({ ...prev, bgmVolume: parseInt(e.target.value) }))}
className = "w-full"
    />
    </div>
    < div >
    <label className="text-gray-300 text-sm" > íš¨ê³¼ìŒ </label>
        < input
type = "range"
min = "0"
max = "100"
value = { settings.sfxVolume }
onChange = {(e) => setSettings(prev => ({ ...prev, sfxVolume: parseInt(e.target.value) }))}
className = "w-full"
    />
    </div>
    < div className = "flex items-center justify-between" >
        <span className="text-gray-300" > ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ </span>
            < input
type = "checkbox"
checked = { settings.showDamageNumbers }
onChange = {(e) => setSettings(prev => ({ ...prev, showDamageNumbers: e.target.checked }))}
                />
    </div>
    < div className = "flex items-center justify-between" >
        <span className="text-gray-300" > ë¯¸ë‹ˆë§µ í‘œì‹œ </span>
            < input
type = "checkbox"
checked = { settings.showMinimap }
onChange = {(e) => setSettings(prev => ({ ...prev, showMinimap: e.target.checked }))}
                />
    </div>
    < div className = "flex items-center justify-between" >
        <span className="text-gray-300" > ì•„ì´í…œ ìë™ íšë“ </span>
            < input
type = "checkbox"
checked = { settings.autoLoot }
onChange = {(e) => setSettings(prev => ({ ...prev, autoLoot: e.target.checked }))}
                />
    </div>
    < div className = "pt-4 space-y-2" >
        <button
                  onClick={ saveGame }
className = "w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded"
    >
                  ğŸ’¾ ì €ì¥í•˜ê¸°
    </button>
    < button
onClick = {() => {
    if (confirm('ì •ë§ ê²Œì„ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        localStorage.removeItem('windKingdomSave');
        window.location.reload();
    }
}}
className = "w-full py-2 bg-red-600 hover:bg-red-500 text-white rounded"
    >
                  ğŸ—‘ï¸ ë°ì´í„° ì´ˆê¸°í™”
    </button>
    </div>
    </div>
    </div>
    </div>
      )}

{/* ì—…ì /ì¹­í˜¸ ì°½ */ }
{
    showAchievements && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" >
            <div className="bg-gray-900 border-2 border-purple-600 rounded-lg p-6 w-[700px] max-h-[80vh] overflow-y-auto" >
                <div className="flex justify-between items-center mb-4" >
                    <h2 className="text-xl font-bold text-white" >ğŸ† ì—…ì  & ì¹­í˜¸ </h2>
                        < button onClick = {() => setShowAchievements(false)
} className = "text-gray-400 hover:text-white text-2xl" >& times; </button>
    </div>

{/* í˜„ì¬ ì¹­í˜¸ */ }
<div className="mb-4 p-3 bg-gray-800 rounded" >
    <div className="text-sm text-gray-400 mb-1" > í˜„ì¬ ì¹­í˜¸ </div>
        < div className = "text-lg" style = {{ color: equippedTitle?.color }}>
            { equippedTitle?.name || 'ì—†ìŒ'}
</div>
    </div>

{/* ì¹­í˜¸ ëª©ë¡ */ }
<div className="mb-6" >
    <h3 className="text-lg font-bold text-yellow-400 mb-2" > ì¹­í˜¸ </h3>
        < div className = "grid grid-cols-2 gap-2" >
        {
            titles.map(title => (
                <div
                    key= { title.id }
                    className = {`p-2 rounded border ${title.unlocked ? 'border-yellow-600 bg-gray-800' : 'border-gray-700 bg-gray-900 opacity-50'}`}
            >
            <div className="flex justify-between items-center" >
                <span style={ { color: title.unlocked ? title.color : '#666' } }> { title.name } </span>
{
    title.unlocked && !title.equipped && (
        <button
                          onClick={ () => handleEquipTitle(title.id) }
    className = "text-xs px-2 py-1 bg-yellow-600 hover:bg-yellow-500 rounded"
        >
        ì¥ì°©
        </button>
                      )
}
{ title.equipped && <span className="text-xs text-green-400" > ì¥ì°©ì¤‘ </span> }
</div>
    < div className = "text-xs text-gray-400" > { title.description } </div>
{
    Object.entries(title.bonus).length > 0 && (
        <div className="text-xs text-green-400 mt-1" >
        {
            Object.entries(title.bonus).map(([key, value]) => (
                <span key= { key } className = "mr-2" > +{ value } { key } </span>
            ))
        }
            </div>
                    )
}
</div>
                ))}
</div>
    </div>

{/* ì—…ì  ëª©ë¡ */ }
<div>
    <h3 className="text-lg font-bold text-purple-400 mb-2" > ì—…ì  </h3>
        < div className = "space-y-2" >
        {
            achievements.map(ach => (
                <div
                    key= { ach.id }
                    className = {`p-3 rounded border ${ach.completed ? 'border-green-600 bg-gray-800' : 'border-gray-700 bg-gray-900'}`}
            >
            <div className="flex justify-between items-center" >
                <div className="flex items-center gap-2" >
                    <span className="text-xl" > { ach.icon } </span>
                        < div >
                        <div className="font-bold text-white" > { ach.name } </div>
                            < div className = "text-xs text-gray-400" > { ach.description } </div>
                                </div>
                                </div>
                                < div className = "text-right" >
                                    <div className="text-sm text-gray-300" >
                                        { ach.current.toLocaleString() } / { ach.requirement.toLocaleString() }
                                        </div>
{
    ach.completed && !ach.claimed && (
        <button
                            onClick={ () => handleClaimAchievement(ach.id) }
    className = "text-xs px-2 py-1 bg-green-600 hover:bg-green-500 rounded mt-1"
        >
        ë³´ìƒ ë°›ê¸°
            </button>
                        )
}
{ ach.claimed && <span className="text-xs text-gray-500" > ì™„ë£Œ </span> }
</div>
    </div>
    < div className = "mt-2 h-2 bg-gray-700 rounded-full overflow-hidden" >
        <div
                        className="h-full bg-purple-500"
style = {{ width: `${Math.min(100, (ach.current / ach.requirement) * 100)}%` }}
                      />
    </div>
    </div>
                ))}
</div>
    </div>
    </div>
    </div>
      )}

{/* í« ìƒì  */ }
{
    showPetShop && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" >
            <div className="bg-gray-900 border-2 border-green-600 rounded-lg p-6 w-[600px] max-h-[80vh] overflow-y-auto" >
                <div className="flex justify-between items-center mb-4" >
                    <h2 className="text-xl font-bold text-white" >ğŸ¾ í« ìƒì  </h2>
                        < button onClick = {() => setShowPetShop(false)
} className = "text-gray-400 hover:text-white text-2xl" >& times; </button>
    </div>

{/* í˜„ì¬ í« */ }
{
    activePet && (
        <div className="mb-4 p-3 bg-gray-800 rounded border border-green-500" >
            <div className="text-sm text-gray-400 mb-1" > í™œì„± í« </div>
                < div className = "flex items-center gap-2" >
                    <span className="text-2xl" > { activePet.icon } </span>
                        < span className = "text-lg text-white" > { activePet.name } </span>
                            </div>
                            </div>
            )
}

<div className="grid grid-cols-2 gap-3" >
{
    pets.map(pet => {
        const canBuy = !pet.owned && playerStats.gold >= pet.price && playerStats.level >= pet.requiredLevel;
        const rarityColor = {
            common: 'border-gray-500',
            rare: 'border-blue-500',
            epic: 'border-purple-500',
            legendary: 'border-yellow-500',
        }[pet.rarity];

        return (
            <div
                    key= { pet.id }
        className = {`p-3 rounded border-2 ${rarityColor} ${pet.owned ? 'bg-gray-800' : 'bg-gray-900'}`
    }
                  >
        <div className="flex items-center gap-2 mb-2" >
    <span className="text-3xl" > { pet.icon } </span>
    < div >
    <div className="font-bold text-white" > { pet.name } </div>
    < div className = "text-xs text-gray-400" > Lv.{ pet.requiredLevel } ì´ìƒ </div>
    </div>
    </div>
    < div className = "text-xs text-green-400 mb-2" >
    { pet.bonus.goldBonus && <div>ê³¨ë“œ + { pet.bonus.goldBonus } % </div> }
                      { pet.bonus.expBonus && <div>ê²½í—˜ì¹˜ + { pet.bonus.expBonus } % </div> }
                      { pet.bonus.attackBonus && <div>ê³µê²©ë ¥ + { pet.bonus.attackBonus } % </div> }
                      { pet.bonus.hpRegen && <div>HP ì¬ìƒ + { pet.bonus.hpRegen } / ì´ˆ </div>}
{ pet.bonus.mpRegen && <div>MP ì¬ìƒ + { pet.bonus.mpRegen } / ì´ˆ </div> }
</div>
{
    !pet.owned ? (
        <button
                        onClick= {() => handleBuyPet(pet.id)
}
disabled = {!canBuy}
className = {`w-full py-1 rounded text-sm ${canBuy ? 'bg-green-600 hover:bg-green-500' : 'bg-gray-700 cursor-not-allowed'}`}
                      >
    { pet.price.toLocaleString() } G
        </button>
                    ) : (
    <button
                        onClick= {() => handleActivatePet(pet.id)}
className = {`w-full py-1 rounded text-sm ${pet.active ? 'bg-yellow-600' : 'bg-blue-600 hover:bg-blue-500'}`}
                      >
    { pet.active ? 'í™œì„±í™”ë¨' : 'í™œì„±í™”' }
    </button>
                    )}
</div>
                );
              })}
</div>
    </div>
    </div>
      )}

{/* í†µê³„ ì°½ */ }
{
    showStats && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" >
            <div className="bg-gray-900 border-2 border-blue-600 rounded-lg p-6 w-96" >
                <div className="flex justify-between items-center mb-4" >
                    <h2 className="text-xl font-bold text-white" >ğŸ“Š í†µê³„ </h2>
                        < button onClick = {() => setShowStats(false)
} className = "text-gray-400 hover:text-white text-2xl" >& times; </button>
    </div>
    < div className = "space-y-2 text-gray-300" >
        <div className="flex justify-between" > <span>ì´ ì²˜ì¹˜ ìˆ˜ < /span><span className="text-white">{gameStats.totalKills.toLocaleString()}</span > </div>
            < div className = "flex justify-between" > <span>ëˆ„ì  ë°ë¯¸ì§€ < /span><span className="text-white">{gameStats.totalDamageDealt.toLocaleString()}</span > </div>
                < div className = "flex justify-between" > <span>íšë“ ê³¨ë“œ < /span><span className="text-yellow-400">{gameStats.totalGoldEarned.toLocaleString()}</span > </div>
                    < div className = "flex justify-between" > <span>ìµœê³  ì½¤ë³´ < /span><span className="text-purple-400">{gameStats.highestCombo}</span > </div>
                        < div className = "flex justify-between" > <span>ì‚¬ë§ íšŸìˆ˜ < /span><span className="text-red-400">{gameStats.totalDeaths}</span > </div>
                            < hr className = "border-gray-700" />
                                <div className="flex justify-between" > <span>ë¶„ë‹¹ ì²˜ì¹˜ < /span><span className="text-green-400">{gameStats.playTime > 0 ? (gameStats.totalKills /(gameStats.playTime / 60)).toFixed(1) : 0}</span></div >
                                    <div className="flex justify-between" > <span>í‰ê·  DPS < /span><span className="text-orange-400">{gameStats.playTime > 0 ? (gameStats.totalDamageDealt / gameStats.playTime).toFixed(0) : 0}</span></div >
                                        </div>
                                        </div>
                                        </div>
      )}

{/* ì¼ì¼ ë³´ìƒ */ }
{
    showDailyReward && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" >
            <div className="bg-gray-900 border-2 border-yellow-600 rounded-lg p-6 w-80 text-center" >
                <h2 className="text-xl font-bold text-yellow-400 mb-4" >ğŸ ì¼ì¼ ë³´ìƒ </h2>
                    < div className = "text-gray-300 mb-4" >
                        <div>ì—°ì† ì¶œì„: { dailyReward.streak } ì¼ </div>
                            < div className = "text-2xl my-4" >
                ğŸ’° { Math.floor(100 * (1 + dailyReward.streak * 0.1)) } ê³¨ë“œ < br />
                âœ¨ { Math.floor(50 * (1 + dailyReward.streak * 0.1)) } ê²½í—˜ì¹˜
        </div>
        </div>
        < button
    onClick = { handleClaimDailyReward }
    disabled = {!dailyReward.canClaim
}
className = {`w-full py-2 rounded ${dailyReward.canClaim ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-gray-700'}`}
            >
    { dailyReward.canClaim ? 'ë°›ê¸°' : 'ì´ë¯¸ ë°›ìŒ' }
    </button>
    < button
onClick = {() => setShowDailyReward(false)}
className = "w-full py-2 mt-2 bg-gray-700 hover:bg-gray-600 rounded"
    >
    ë‹«ê¸°
    </button>
    </div>
    </div>
      )}

{/* ì½”ë“œ ë·°ì–´ */ }
{
    showCodeViewer && (
        <CodeViewer onClose={ () => setShowCodeViewer(false) } />
      )
}

{/* ì½”ë“œ ë³´ê¸° ë²„íŠ¼ */ }
<button
        onClick={ () => setShowCodeViewer(true) }
className = "absolute bottom-4 left-4 px-3 py-2 bg-gray-800 hover:bg-gray-700 text-white text-sm rounded-lg border border-gray-600 transition-colors z-50"
    >
        ğŸ“‹ ì½”ë“œ ë³´ê¸°
    </button>
    </div>
  );
}

export default App;
ğŸ“ src / game / GameConfig.ts
TypeScript

import Phaser from 'phaser';
import { BootScene } from './scenes/BootScene';
import { TownScene } from './scenes/TownScene';
import { DungeonScene } from './scenes/DungeonScene';

export const gameConfig: Phaser.Types.Core.GameConfig = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: 1920,
    height: 1080,
    pixelArt: true,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { x: 0, y: 0 },
            debug: false,
        },
    },
    scene: [BootScene, TownScene, DungeonScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
};
ğŸ“ src / game / GameEventBus.ts
TypeScript

type EventCallback = (...args: unknown[]) => void;

class EventBus {
    private events: Map<string, EventCallback[]> = new Map();

    on(event: string, callback: EventCallback) {
        if (!this.events.has(event)) {
            this.events.set(event, []);
        }
        this.events.get(event)!.push(callback);
    }

    off(event: string, callback: EventCallback) {
        const callbacks = this.events.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    emit(event: string, ...args: unknown[]) {
        const callbacks = this.events.get(event);
        if (callbacks) {
            callbacks.forEach((callback) => callback(...args));
        }
    }
}

export const GameEventBus = new EventBus();
ğŸ“ src / game / scenes / BootScene.ts
TypeScript

import Phaser from 'phaser';

export class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }

    preload() {
        const width = this.cameras.main.width;
        const height = this.cameras.main.height;

        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(width / 2 - 160, height / 2 - 25, 320, 50);

        const loadingText = this.add.text(width / 2, height / 2 - 50, 'ë¡œë”© ì¤‘...', {
            fontSize: '20px',
            color: '#ffffff',
        });
        loadingText.setOrigin(0.5, 0.5);

        this.load.on('progress', (value: number) => {
            progressBar.clear();
            progressBar.fillStyle(0x00ff00, 1);
            progressBar.fillRect(width / 2 - 150, height / 2 - 15, 300 * value, 30);
        });

        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.destroy();
        });

        this.createTextures();
    }

    createTextures() {
        // í”Œë ˆì´ì–´ ìºë¦­í„°
        const playerGraphics = this.make.graphics({ x: 0, y: 0 });

        // ê·¸ë¦¼ì
        playerGraphics.fillStyle(0x000000, 0.3);
        playerGraphics.fillEllipse(24, 60, 32, 12);

        // ì‹ ë°œ
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRoundedRect(12, 52, 10, 8, 2);
        playerGraphics.fillRoundedRect(26, 52, 10, 8, 2);

        // ë‹¤ë¦¬
        playerGraphics.fillStyle(0x2d3a4a);
        playerGraphics.fillRect(14, 40, 8, 14);
        playerGraphics.fillRect(26, 40, 8, 14);
        playerGraphics.fillStyle(0x232d3a);
        playerGraphics.fillRect(15, 42, 2, 10);
        playerGraphics.fillRect(27, 42, 2, 10);

        // ë„í¬
        playerGraphics.fillStyle(0x3498db);
        playerGraphics.fillRoundedRect(8, 20, 32, 24, 4);
        playerGraphics.fillStyle(0x2980b9);
        playerGraphics.fillRoundedRect(8, 20, 10, 24, 4);
        playerGraphics.fillStyle(0x5dade2);
        playerGraphics.fillRoundedRect(30, 22, 8, 18, 2);

        // í—ˆë¦¬ë 
        playerGraphics.fillStyle(0xf39c12);
        playerGraphics.fillRect(8, 38, 32, 4);
        playerGraphics.fillStyle(0xe67e22);
        playerGraphics.fillRect(8, 40, 32, 2);
        playerGraphics.fillStyle(0xf1c40f);
        playerGraphics.fillCircle(24, 40, 4);
        playerGraphics.fillStyle(0xe67e22);
        playerGraphics.fillCircle(24, 40, 2);

        // ì†Œë§¤
        playerGraphics.fillStyle(0x3498db);
        playerGraphics.fillEllipse(6, 28, 10, 14);
        playerGraphics.fillEllipse(42, 28, 10, 14);
        playerGraphics.fillStyle(0x5dade2);
        playerGraphics.fillEllipse(8, 26, 6, 8);
        playerGraphics.fillEllipse(40, 26, 6, 8);

        // ì†
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillCircle(4, 34, 4);
        playerGraphics.fillCircle(44, 34, 4);
        playerGraphics.fillStyle(0xf5cba7);
        playerGraphics.fillCircle(3, 33, 2);
        playerGraphics.fillCircle(43, 33, 2);

        // ëª©
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillRect(20, 14, 8, 8);

        // ì–¼êµ´
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillRoundedRect(14, 2, 20, 18, 6);
        playerGraphics.fillStyle(0xf5cba7);
        playerGraphics.fillRoundedRect(14, 10, 20, 8, 4);

        // ë¨¸ë¦¬ì¹´ë½
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRoundedRect(12, 0, 24, 10, 4);
        playerGraphics.fillStyle(0x2c2c3e);
        playerGraphics.fillEllipse(24, -2, 12, 8);
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillEllipse(24, -4, 8, 6);
        playerGraphics.fillStyle(0x3d3d5c);
        playerGraphics.fillRect(16, 2, 2, 4);

        // ëˆˆ
        playerGraphics.fillStyle(0xffffff);
        playerGraphics.fillEllipse(18, 8, 5, 4);
        playerGraphics.fillEllipse(30, 8, 5, 4);
        playerGraphics.fillStyle(0x2c2c3e);
        playerGraphics.fillCircle(19, 8, 2);
        playerGraphics.fillCircle(31, 8, 2);
        playerGraphics.fillStyle(0xffffff);
        playerGraphics.fillCircle(20, 7, 1);
        playerGraphics.fillCircle(32, 7, 1);

        // ëˆˆì¹
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRect(16, 4, 6, 1);
        playerGraphics.fillRect(28, 4, 6, 1);

        // ì…
        playerGraphics.fillStyle(0xc0392b);
        playerGraphics.fillRect(22, 14, 4, 1);

        // ë³¼í„°ì¹˜
        playerGraphics.fillStyle(0xf1948a, 0.5);
        playerGraphics.fillCircle(16, 12, 2);
        playerGraphics.fillCircle(32, 12, 2);

        playerGraphics.generateTexture('player', 48, 64);
        playerGraphics.destroy();

        // NPC í…ìŠ¤ì²˜ë“¤
        this.createNPCTexture('npc_blacksmith', 0x8B4513, 0xDC143C);
        this.createNPCTexture('npc_innkeeper', 0xDAA520, 0x8B0000);
        this.createNPCTexture('npc_alchemist', 0x9932CC, 0x4B0082);
        this.createNPCTexture('npc_sage', 0x4169E1, 0x000080);
        this.createNPCTexture('npc_merchant', 0x228B22, 0x006400);

        // ëª¬ìŠ¤í„° í…ìŠ¤ì²˜ë“¤
        this.createMonsterTexture('monster_slime', 0x00ff00, 'slime');
        this.createMonsterTexture('monster_bat', 0x8B4513, 'bat');
        this.createMonsterTexture('monster_wolf', 0x808080, 'wolf');
        this.createMonsterTexture('monster_ghost', 0xE8E8E8, 'ghost');
        this.createMonsterTexture('monster_goblin', 0x90EE90, 'goblin');
        this.createMonsterTexture('monster_orc', 0x556B2F, 'orc');
        this.createMonsterTexture('monster_skeleton', 0xFFFACD, 'skeleton');
        this.createMonsterTexture('monster_demon', 0x8B0000, 'demon');
        this.createMonsterTexture('monster_dragon', 0xFF4500, 'dragon');
        this.createMonsterTexture('monster_boss', 0x4B0082, 'boss');

        // ì•„ì´í…œ í…ìŠ¤ì²˜
        this.createItemTexture('item_gold', 0xFFD700);
        this.createItemTexture('item_potion', 0xFF0000);
        this.createItemTexture('item_weapon', 0xC0C0C0);

        // ì´í™íŠ¸ í…ìŠ¤ì²˜
        this.createEffectTexture('effect_slash', 0xFFFFFF);
        this.createEffectTexture('effect_fire', 0xFF4500);
        this.createEffectTexture('effect_heal', 0x00FF00);
        this.createEffectTexture('effect_thunder', 0xFFFF00);
        this.createEffectTexture('effect_ice', 0x00FFFF);

        // íƒ€ì¼ í…ìŠ¤ì²˜
        this.createTileTexture('tile_grass', 0x228B22, 0x32CD32);
        this.createTileTexture('tile_stone', 0x696969, 0x808080);
        this.createTileTexture('tile_dungeon', 0x2F2F2F, 0x3D3D3D);

        // ìš¸íƒ€ë¦¬ í…ìŠ¤ì²˜
        this.createFenceTexture();
    }

    createNPCTexture(key: string, bodyColor: number, accentColor: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        graphics.fillStyle(0x000000, 0.3);
        graphics.fillEllipse(24, 60, 32, 12);

        graphics.fillStyle(0x1a1a2e);
        graphics.fillRoundedRect(12, 52, 10, 8, 2);
        graphics.fillRoundedRect(26, 52, 10, 8, 2);

        graphics.fillStyle(0x2d3a4a);
        graphics.fillRect(14, 40, 8, 14);
        graphics.fillRect(26, 40, 8, 14);

        graphics.fillStyle(bodyColor);
        graphics.fillRoundedRect(8, 20, 32, 24, 4);

        graphics.fillStyle(accentColor);
        graphics.fillRect(14, 28, 20, 14);

        graphics.fillStyle(0xf39c12);
        graphics.fillRect(8, 38, 32, 4);

        graphics.fillStyle(bodyColor);
        graphics.fillEllipse(6, 28, 10, 14);
        graphics.fillEllipse(42, 28, 10, 14);

        graphics.fillStyle(0xfad7a0);
        graphics.fillCircle(4, 34, 4);
        graphics.fillCircle(44, 34, 4);

        graphics.fillStyle(0xfad7a0);
        graphics.fillRect(20, 14, 8, 8);

        graphics.fillStyle(0xfad7a0);
        graphics.fillRoundedRect(14, 2, 20, 18, 6);

        graphics.fillStyle(0x1a1a2e);
        graphics.fillRoundedRect(12, 0, 24, 8, 4);

        graphics.fillStyle(0x2c2c3e);
        graphics.fillCircle(19, 8, 2);
        graphics.fillCircle(31, 8, 2);

        graphics.fillStyle(0xc0392b);
        graphics.fillRect(22, 14, 4, 1);

        graphics.generateTexture(key, 48, 64);
        graphics.destroy();
    }

    createMonsterTexture(key: string, color: number, type: string) {
        const graphics = this.make.graphics({ x: 0, y: 0 });
        const size = 40;

        graphics.fillStyle(0x000000, 0.4);
        graphics.fillEllipse(size / 2, size - 4, size * 0.8, 8);

        switch (type) {
            case 'slime':
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, size * 0.8, size * 0.6);
                graphics.fillStyle(0xffffff, 0.6);
                graphics.fillEllipse(size / 2 - 6, size / 2 - 2, 8, 6);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 5, size / 2 + 2, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 + 2, 3);
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(size / 2 - 4, size / 2 + 1, 1);
                graphics.fillCircle(size / 2 + 6, size / 2 + 1, 1);
                break;

            case 'bat':
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2, 16, 12);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillTriangle(size / 2 - 8, size / 2, 2, size / 2 - 10, 2, size / 2 + 6);
                graphics.fillTriangle(size / 2 + 8, size / 2, size - 2, size / 2 - 10, size - 2, size / 2 + 6);
                graphics.fillStyle(color);
                graphics.fillTriangle(size / 2 - 6, size / 2 - 6, size / 2 - 10, size / 2 - 14, size / 2 - 2, size / 2 - 6);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 6, size / 2 + 10, size / 2 - 14, size / 2 + 2, size / 2 - 6);
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 4, size / 2, 2);
                graphics.fillCircle(size / 2 + 4, size / 2, 2);
                break;

            case 'wolf':
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, 28, 18);
                graphics.fillCircle(size / 2 + 10, size / 2 - 2, 10);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).lighten(20).color);
                graphics.fillEllipse(size / 2 + 16, size / 2, 8, 5);
                graphics.fillStyle(color);
                graphics.fillTriangle(size / 2 + 4, size / 2 - 8, size / 2 + 8, size / 2 - 16, size / 2 + 12, size / 2 - 8);
                graphics.fillTriangle(size / 2 + 10, size / 2 - 8, size / 2 + 14, size / 2 - 16, size / 2 + 18, size / 2 - 8);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 8, size / 2 - 4, 2);
                graphics.fillEllipse(size / 2 - 14, size / 2 - 2, 10, 6);
                break;

            case 'ghost':
                graphics.fillStyle(color, 0.8);
                graphics.fillEllipse(size / 2, size / 2 - 2, 24, 20);
                graphics.fillTriangle(size / 2 - 12, size / 2 + 6, size / 2 - 6, size + 2, size / 2, size / 2 + 6);
                graphics.fillTriangle(size / 2, size / 2 + 6, size / 2 + 6, size + 2, size / 2 + 12, size / 2 + 6);
                graphics.fillStyle(0x000000);
                graphics.fillEllipse(size / 2 - 5, size / 2 - 2, 6, 8);
                graphics.fillEllipse(size / 2 + 5, size / 2 - 2, 6, 8);
                graphics.fillEllipse(size / 2, size / 2 + 6, 8, 4);
                break;

            case 'goblin':
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 10, size / 2 - 4, 20, 20, 4);
                graphics.fillCircle(size / 2, size / 2 - 8, 12);
                graphics.fillTriangle(size / 2 - 12, size / 2 - 8, size / 2 - 18, size / 2 - 16, size / 2 - 8, size / 2 - 12);
                graphics.fillTriangle(size / 2 + 12, size / 2 - 8, size / 2 + 18, size / 2 - 16, size / 2 + 8, size / 2 - 12);
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 1);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 1);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillCircle(size / 2, size / 2 - 6, 3);
                break;

            case 'orc':
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 14, size / 2 - 2, 28, 22, 4);
                graphics.fillCircle(size / 2, size / 2 - 10, 14);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(10).color);
                graphics.fillRect(size / 2 - 8, size / 2 - 4, 16, 6);
                graphics.fillStyle(0xffffff);
                graphics.fillTriangle(size / 2 - 6, size / 2 - 4, size / 2 - 4, size / 2 + 2, size / 2 - 2, size / 2 - 4);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 4, size / 2 + 4, size / 2 + 2, size / 2 + 2, size / 2 - 4);
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 12, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 - 12, 3);
                break;

            case 'skeleton':
                graphics.fillStyle(color);
                graphics.fillRect(size / 2 - 6, size / 2 - 4, 12, 18);
                graphics.fillStyle(0x000000);
                for (let i = 0; i < 4; i++) {
                    graphics.fillRect(size / 2 - 5, size / 2 - 2 + i * 4, 10, 1);
                }
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2 - 10, 10);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                graphics.fillTriangle(size / 2, size / 2 - 8, size / 2 - 2, size / 2 - 4, size / 2 + 2, size / 2 - 4);
                graphics.fillRect(size / 2 - 5, size / 2 - 3, 10, 2);
                break;

            case 'demon':
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 12, size / 2 - 4, 24, 22, 4);
                graphics.fillCircle(size / 2, size / 2 - 10, 12);
                graphics.fillStyle(0x2c0000);
                graphics.fillTriangle(size / 2 - 10, size / 2 - 14, size / 2 - 14, size / 2 - 26, size / 2 - 6, size / 2 - 14);
                graphics.fillTriangle(size / 2 + 10, size / 2 - 14, size / 2 + 14, size / 2 - 26, size / 2 + 6, size / 2 - 14);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 1);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 1);
                graphics.fillStyle(0x4a0000);
                graphics.fillTriangle(size / 2 - 12, size / 2, 0, size / 2 - 14, 0, size / 2 + 8);
                graphics.fillTriangle(size / 2 + 12, size / 2, size, size / 2 - 14, size, size / 2 + 8);
                break;

            case 'dragon':
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, 30, 20);
                graphics.fillCircle(size / 2 + 12, size / 2 - 4, 12);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(10).color);
                graphics.fillEllipse(size / 2 + 20, size / 2 - 2, 10, 6);
                graphics.fillStyle(0xffd700);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 10, size / 2 + 4, size / 2 - 20, size / 2 + 10, size / 2 - 10);
                graphics.fillTriangle(size / 2 + 14, size / 2 - 10, size / 2 + 12, size / 2 - 20, size / 2 + 18, size / 2 - 10);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 14, size / 2 - 6, 3);
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillTriangle(size / 2 - 6, size / 2, size / 2 - 20, size / 2 - 20, size / 2 - 16, size / 2 + 8);
                graphics.fillStyle(0xff4500);
                graphics.fillCircle(size / 2 + 24, size / 2 - 2, 4);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 26, size / 2 - 2, 2);
                break;

            case 'boss':
                graphics.fillStyle(0xffd700);
                graphics.fillTriangle(size / 2 - 12, size / 2 - 20, size / 2 - 8, size / 2 - 28, size / 2 - 4, size / 2 - 20);
                graphics.fillTriangle(size / 2, size / 2 - 20, size / 2, size / 2 - 32, size / 2, size / 2 - 20);
                graphics.fillTriangle(size / 2 + 4, size / 2 - 20, size / 2 + 8, size / 2 - 28, size / 2 + 12, size / 2 - 20);
                graphics.fillRect(size / 2 - 12, size / 2 - 20, 24, 6);
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2 - 8, 14);
                graphics.fillRoundedRect(size / 2 - 14, size / 2 + 2, 28, 20, 4);
                graphics.fillStyle(0x4a0082);
                graphics.fillTriangle(size / 2 - 14, size / 2 + 4, size / 2 - 18, size / 2 + 24, size / 2 - 10, size / 2 + 20);
                graphics.fillTriangle(size / 2 + 14, size / 2 + 4, size / 2 + 18, size / 2 + 24, size / 2 + 10, size / 2 + 20);
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 10, 4);
                graphics.fillCircle(size / 2 + 5, size / 2 - 10, 4);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 - 5, size / 2 - 10, 2);
                graphics.fillCircle(size / 2 + 5, size / 2 - 10, 2);
                break;

            default:
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2, size / 2 - 2);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 4, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 - 4, 3);
        }

        graphics.generateTexture(key, size, size);
        graphics.destroy();
    }

    createItemTexture(key: string, color: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        if (key === 'item_gold') {
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 16, 8);
            graphics.fillStyle(color);
            graphics.fillCircle(12, 12, 10);
            graphics.fillStyle(0xffa500);
            graphics.fillCircle(12, 12, 7);
            graphics.fillStyle(color);
            graphics.fillCircle(12, 12, 4);
            graphics.fillStyle(0xffa500);
            graphics.fillRect(10, 8, 4, 8);
        } else if (key === 'item_potion') {
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 14, 6);
            graphics.fillStyle(0x8B4513);
            graphics.fillRect(8, 2, 8, 4);
            graphics.fillStyle(color);
            graphics.fillRoundedRect(6, 6, 12, 16, 4);
            graphics.fillStyle(0xffffff, 0.4);
            graphics.fillRect(8, 8, 3, 8);
        } else {
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 10, 6);
            graphics.fillStyle(color);
            graphics.fillRect(10, 2, 4, 16);
            graphics.fillStyle(0x8B4513);
            graphics.fillRect(6, 16, 12, 4);
            graphics.fillRect(10, 18, 4, 4);
        }

        graphics.generateTexture(key, 24, 24);
        graphics.destroy();
    }

    createEffectTexture(key: string, color: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        if (key === 'effect_slash') {
            graphics.fillStyle(color, 0.8);
            graphics.fillTriangle(0, 16, 32, 0, 32, 32);
            graphics.fillStyle(0xffffff, 0.6);
            graphics.fillTriangle(4, 16, 28, 4, 28, 28);
        } else if (key === 'effect_fire') {
            graphics.fillStyle(color);
            graphics.fillCircle(16, 20, 12);
            graphics.fillStyle(0xffff00);
            graphics.fillCircle(16, 18, 8);
            graphics.fillStyle(0xffffff);
            graphics.fillCircle(16, 16, 4);
            graphics.fillStyle(color);
            graphics.fillTriangle(16, 4, 8, 16, 24, 16);
        } else if (key === 'effect_heal') {
            graphics.fillStyle(color);
            graphics.fillRect(12, 4, 8, 24);
            graphics.fillRect(4, 12, 24, 8);
            graphics.fillStyle(0xffffff, 0.5);
            graphics.fillRect(14, 6, 4, 20);
            graphics.fillRect(6, 14, 20, 4);
        } else if (key === 'effect_thunder') {
            graphics.fillStyle(color);
            graphics.fillTriangle(16, 0, 8, 16, 20, 14);
            graphics.fillTriangle(12, 12, 4, 32, 24, 18);
            graphics.fillStyle(0xffffff, 0.7);
            graphics.fillTriangle(14, 4, 10, 14, 18, 12);
        } else if (key === 'effect_ice') {
            graphics.fillStyle(color);
            graphics.fillRect(14, 2, 4, 28);
            graphics.fillRect(2, 14, 28, 4);
            graphics.fillRect(6, 6, 20, 20);
            graphics.fillStyle(0xffffff);
            graphics.fillCircle(16, 16, 6);
        }

        graphics.generateTexture(key, 32, 32);
        graphics.destroy();
    }

    createTileTexture(key: string, color1: number, color2: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        graphics.fillStyle(color1);
        graphics.fillRect(0, 0, 64, 64);

        graphics.fillStyle(color2);
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                if ((i + j) % 2 === 0) {
                    graphics.fillRect(i * 8, j * 8, 8, 8);
                }
            }
        }

        graphics.lineStyle(1, Phaser.Display.Color.ValueToColor(color1).darken(30).color, 0.3);
        graphics.strokeRect(0, 0, 64, 64);

        graphics.generateTexture(key, 64, 64);
        graphics.destroy();
    }

    createFenceTexture() {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        // ë‚˜ë¬´ ìš¸íƒ€ë¦¬ ê¸°ë‘¥
        graphics.fillStyle(0x8B4513);
        graphics.fillRect(0, 0, 16, 64);
        graphics.fillRect(48, 0, 16, 64);

        // ê°€ë¡œ ë§‰ëŒ€
        graphics.fillStyle(0xA0522D);
        graphics.fillRect(0, 8, 64, 8);
        graphics.fillRect(0, 32, 64, 8);
        graphics.fillRect(0, 48, 64, 8);

        // í•˜ì´ë¼ì´íŠ¸
        graphics.fillStyle(0xCD853F, 0.5);
        graphics.fillRect(2, 0, 4, 64);
        graphics.fillRect(50, 0, 4, 64);

        graphics.generateTexture('fence', 64, 64);
        graphics.destroy();

        // ëª¨ì„œë¦¬ ê¸°ë‘¥
        const cornerGraphics = this.make.graphics({ x: 0, y: 0 });
        cornerGraphics.fillStyle(0x654321);
        cornerGraphics.fillRect(0, 0, 32, 64);
        cornerGraphics.fillStyle(0x8B4513);
        cornerGraphics.fillRect(4, 0, 24, 60);
        cornerGraphics.fillStyle(0xA0522D);
        cornerGraphics.fillRect(8, 0, 16, 56);

        cornerGraphics.generateTexture('fence_corner', 32, 64);
        cornerGraphics.destroy();
    }

    create() {
        this.scene.start('TownScene');
    }
}
ğŸ“ src / game / scenes / TownScene.ts
TypeScript

import Phaser from 'phaser';
import { GameEventBus } from '../GameEventBus';
import { NPC_DATA } from '../data/npcs';

interface PlayerStats {
    hp: number;
    maxHp: number;
    mp: number;
    maxMp: number;
    level: number;
    exp: number;
    expToNext: number;
    gold: number;
    attack: number;
    defense: number;
}

export class TownScene extends Phaser.Scene {
    private player!: Phaser.Physics.Arcade.Sprite;
    private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
    private npcs: Phaser.Physics.Arcade.Sprite[] = [];
    private playerStats: PlayerStats = {
        hp: 100,
        maxHp: 100,
        mp: 50,
        maxMp: 50,
        level: 1,
        exp: 0,
        expToNext: 100,
        gold: 1000,
        attack: 10,
        defense: 5,
    };
    private nearbyNPC: Phaser.Physics.Arcade.Sprite | null = null;
    private interactionText!: Phaser.GameObjects.Text;
    private dialogueBox: Phaser.GameObjects.Container | null = null;

    constructor() {
        super({ key: 'TownScene' });
    }

    create() {
        this.physics.world.setBounds(0, 0, 2400, 1800);

        // ë°°ê²½ íƒ€ì¼
        for (let x = 0; x < 2400; x += 64) {
            for (let y = 0; y < 1800; y += 64) {
                this.add.image(x + 32, y + 32, 'tile_grass');
            }
        }

        // ë§ˆì„ ì¤‘ì•™ ê´‘ì¥
        for (let x = 800; x < 1600; x += 64) {
            for (let y = 600; y < 1200; y += 64) {
                this.add.image(x + 32, y + 32, 'tile_stone');
            }
        }

        // í”Œë ˆì´ì–´ ìƒì„±
        this.player = this.physics.add.sprite(1200, 900, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.setDepth(10);
        this.player.setScale(1.5);

        // ì¹´ë©”ë¼ ì„¤ì •
        this.cameras.main.setBounds(0, 0, 2400, 1800);
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        this.cameras.main.setZoom(1);

        // NPC ìƒì„±
        this.createNPCs();

        // ì…ë ¥ ì„¤ì •
        this.cursors = this.input.keyboard!.createCursorKeys();
        this.setupInput();

        // ìƒí˜¸ì‘ìš© í…ìŠ¤íŠ¸
        this.interactionText = this.add.text(0, 0, '', {
            fontSize: '16px',
            color: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 8, y: 4 },
        });
        this.interactionText.setDepth(100);
        this.interactionText.setVisible(false);

        // ë§ˆì„ ì´ë¦„ í‘œì‹œ
        const townTitle = this.add.text(1200, 100, 'âš”ï¸ ë°”ëŒì˜ ë§ˆì„ âš”ï¸', {

            ì§€ê¸ˆ ë§ˆì§€ë§‰ ìˆ˜ì •í•´ì¤€ ê²Œì„ ì½”ë“œë¥¼ ì „ì²´ ë³µì‚¬í•  ìˆ˜ ìˆê²Œ ì œê³µí•´ì¤˜

claude- opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second

Built the project


Show More



ì—…ë°ì´íŠ¸ëœ ê²Œì„ì„ ì‹¤í–‰ì‹œì¼œì¤˜

        claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second

ë¨¼ì € í˜„ì¬ íŒŒì¼ë“¤ì„ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.


            Listed 36 files







Show More



            - ë ˆë²¨ì—… ì¶•í•˜ ë©”ì„¸ì§€ëŠ” ì¤‘ì•™ì— í¬ê²Œ í™”ë©´ì„ ê°€ë¦¬ì§€ ë§ê³  ìš°ì¸¡í•˜ë‹¨ì— ì•Œë¦¼ìœ¼ë¡œ ë‚˜ì˜¤ê²Œ í•´ì¤˜
                - ì´ˆë°˜ì˜ ì¬ë¯¸ë¥¼ ìœ„í•´ 30ë ˆë²¨ê¹Œì§€ëŠ” ì„±ì¥ì´ ì‰½ê²Œ ë§Œë“¤ì–´ì¤˜
                    - ì•„ì´í…œì°½ì´ë‚˜ ë‹¤ë¥¸ ì°½ì´ ì—´ë ¤ìˆì„ë•ŒëŠ” esc ë²„íŠ¼ì´ "ë’¤ë¡œê°€ê¸°" ì—­í• ê³¼ "ì°½ ì¢…ë£Œ"ì—­í• ì„ í•˜ê²Œí•´ì¤˜
                        - ë‚´ê°€ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” íšë“ ì•„ì´í…œì€ íŒ”ì•„ì„œ ì¬í™”ë¡œ ë³€ê²½í•  ìˆ˜ ìˆê²Œ í•´ì¤˜
                            - ìŠ¤ìŠ¤ë¡œ í•™ìŠµí•´ì„œ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆëŠ” ìœ ìš©í•œ ê¸°ëŠ¥ë“¤ì„ ì¶”ê°€í•´ì¤˜
                                - ë‚´ê°€ ë°–ìœ¼ë¡œ ì´ë™í•˜ì§€ ëª»í•˜ëŠ” ì§€ì—­ì€ ëª¬ìŠ¤í„°ë„ ë‚˜ê°€ì§€ ëª»í•˜ê²Œí•˜ê³  ìš¸íƒ€ë¦¬ë¥¼ ì³ì¤˜
                                    - ìŠ¤ìŠ¤ë¡œ í•™ìŠµí•´ì„œ ë§µë””ìì¸, ìºë¦­í„°ë””ìì¸, ì¸ë²¤í† ë¦¬ ë“± ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆë‹¤ë©´ ì—…ë°ì´íŠ¸í•´ì¤˜

        claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second

Built the project



Show More



ê²Œì„ì„ í•œë²ˆ ì‹¤í–‰ì‹œì¼œì¤˜

        claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 2 seconds

í˜„ì¬ í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ê³  ìœ ìš©í•œ ê¸°ëŠ¥ë“¤ì„ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.ë¨¼ì € íŒŒì¼ë“¤ì„ í™•ì¸í•©ë‹ˆë‹¤.


            Listed 28 files








Show More



ê²Œì„ ì½”ë“œë¥¼ ë¶„ì„í•´ì„œ ìŠ¤ìŠ¤ë¡œ í•™ìŠµí•˜ê³  ìœ ìš©í•œ ê¸°ëŠ¥ë“¤ì„ ì—…ë°ì´íŠ¸í•´ì¤˜

        claude - opus - 4 - 5 - 20251101
        ë„¤, ì „ì²´ ì½”ë“œë¥¼ ì—¬ê¸°ì— í…ìŠ¤íŠ¸ë¡œ ì œê³µí•˜ê² ìŠµë‹ˆë‹¤.ëª¨ë“  íŒŒì¼ì„ í•œë²ˆì— ë³µì‚¬í•  ìˆ˜ ìˆë„ë¡ ì •ë¦¬í•©ë‹ˆë‹¤.

ğŸ“¦ ì „ì²´ í”„ë¡œì íŠ¸ ì½”ë“œ
        1. index.html
        HTML

            < !DOCTYPE html >
                <html lang="ko" >
                    <head>
                    <meta charset="UTF-8" />
                        <link rel="icon" type = "image/svg+xml" href = "/vite.svg" />
                            <meta name="viewport" content = "width=device-width, initial-scale=1.0" />
                                <title>ë°”ëŒì˜ ë‚˜ë¼ - í´ë˜ì‹ RPG </title>
                                    <style>
                                    * {
                                    margin: 0;
                                    padding: 0;
                                    box- sizing: border - box;
    }
      body {
    overflow: hidden;
    background - color: #000;
}
</style>
    </head>
    < body >
    <div id="root" > </div>
        < script type = "module" src = "/src/main.tsx" > </script>
            </body>
            </html>
2. src / main.tsx
React

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
    <StrictMode>
    <App />
    </StrictMode>,
)
3. src / App.tsx
React

import { useEffect, useRef, useState, useCallback } from 'react';
import Phaser from 'phaser';
import { gameConfig } from './game/GameConfig';
import { GameEventBus } from './game/GameEventBus';
import HUD from './components/UI/HUD';
import Inventory from './components/UI/Inventory';
import DungeonSelector from './components/UI/DungeonSelector';
import SkillBar from './components/UI/SkillBar';
import QuestPanel from './components/UI/QuestPanel';
import CodeViewer from './components/UI/CodeViewer';

// íƒ€ì… ì •ì˜
interface PlayerStats {
    hp: number;
    maxHp: number;
    mp: number;
    maxMp: number;
    level: number;
    exp: number;
    expToNext: number;
    gold: number;
    attack: number;
    defense: number;
}

interface InventoryItem {
    id: string;
    name: string;
    type: 'weapon' | 'armor' | 'consumable' | 'material' | 'skillbook';
    icon: string;
    quantity: number;
    description: string;
    price: number;
    effect?: {
        hp?: number;
        mp?: number;
        attack?: number;
        defense?: number;
    };
    requiredLevel?: number;
}

interface Skill {
    id: string;
    name: string;
    icon: string;
    damage: number;
    mpCost: number;
    cooldown: number;
    currentCooldown: number;
    requiredLevel: number;
    description: string;
}

interface QuickSlot {
    slot: number;
    item: InventoryItem | null;
}

interface ActiveBuff {
    id: string;
    name: string;
    icon: string;
    duration: number;
    remainingTime: number;
    effect: {
        attack?: number;
        defense?: number;
        speed?: number;
    };
}

interface Quest {
    id: string;
    title: string;
    description: string;
    type: 'daily' | 'main' | 'side';
    objectives: {
        type: string;
        target: string;
        current: number;
        required: number;
    }[];
    rewards: {
        exp?: number;
        gold?: number;
        items?: { id: string; quantity: number }[];
    };
    completed: boolean;
    claimed: boolean;
}

interface CombatStats {
    totalDamage: number;
    killCount: number;
    critCount: number;
    hitCount: number;
    startTime: number;
    dps: number;
}

interface MinimapData {
    playerX: number;
    playerY: number;
    worldWidth: number;
    worldHeight: number;
    monsters: { x: number; y: number; isBoss: boolean }[];
}

function App() {
    const gameRef = useRef<Phaser.Game | null>(null);
    const [currentScene, setCurrentScene] = useState<string>('boot');
    const [playerStats, setPlayerStats] = useState<PlayerStats>({
        hp: 100,
        maxHp: 100,
        mp: 50,
        maxMp: 50,
        level: 1,
        exp: 0,
        expToNext: 100,
        gold: 1000,
        attack: 10,
        defense: 5,
    });
    const [inventory, setInventory] = useState<InventoryItem[]>([
        {
            id: 'hp_potion_1',
            name: 'ë™ë™ì£¼',
            type: 'consumable',
            icon: 'ğŸ¶',
            quantity: 10,
            description: 'HPë¥¼ 50 íšŒë³µí•©ë‹ˆë‹¤.',
            price: 50,
            effect: { hp: 50 },
        },
        {
            id: 'mp_potion_1',
            name: 'ë§ˆë ¥ ë¬¼ì•½',
            type: 'consumable',
            icon: 'ğŸ’§',
            quantity: 5,
            description: 'MPë¥¼ 30 íšŒë³µí•©ë‹ˆë‹¤.',
            price: 80,
            effect: { mp: 30 },
        },
    ]);
    const [skills, setSkills] = useState<Skill[]>([
        {
            id: 'slash',
            name: 'ì°¸ê²©',
            icon: 'âš”ï¸',
            damage: 25,
            mpCost: 5,
            cooldown: 1000,
            currentCooldown: 0,
            requiredLevel: 1,
            description: 'ê¸°ë³¸ ê²€ìˆ  ê³µê²©',
        },
        {
            id: 'fireball',
            name: 'í™”ì—¼êµ¬',
            icon: 'ğŸ”¥',
            damage: 50,
            mpCost: 15,
            cooldown: 3000,
            currentCooldown: 0,
            requiredLevel: 5,
            description: 'ê°•ë ¥í•œ í™”ì—¼ ë§ˆë²•',
        },
        {
            id: 'heal',
            name: 'ì¹˜ìœ ',
            icon: 'ğŸ’š',
            damage: 0,
            mpCost: 20,
            cooldown: 5000,
            currentCooldown: 0,
            requiredLevel: 3,
            description: 'HPë¥¼ 30 íšŒë³µ',
        },
        {
            id: 'thunder',
            name: 'ë‚™ë¢°',
            icon: 'âš¡',
            damage: 80,
            mpCost: 25,
            cooldown: 4000,
            currentCooldown: 0,
            requiredLevel: 10,
            description: 'ë²ˆê°œë¥¼ ì†Œí™˜í•˜ì—¬ ê³µê²©',
        },
        {
            id: 'ice_storm',
            name: 'ë¹™í’',
            icon: 'â„ï¸',
            damage: 60,
            mpCost: 20,
            cooldown: 3500,
            currentCooldown: 0,
            requiredLevel: 8,
            description: 'ì–¼ìŒ í­í’ìœ¼ë¡œ ë²”ìœ„ ê³µê²©',
        },
        {
            id: 'battle_cry',
            name: 'ì „íˆ¬í•¨ì„±',
            icon: 'ğŸ“¯',
            damage: 0,
            mpCost: 30,
            cooldown: 10000,
            currentCooldown: 0,
            requiredLevel: 15,
            description: '10ì´ˆê°„ ê³µê²©ë ¥ 50% ì¦ê°€',
        },
    ]);
    const [quickSlots, setQuickSlots] = useState<QuickSlot[]>([
        { slot: 0, item: null },
        { slot: 1, item: null },
        { slot: 2, item: null },
        { slot: 3, item: null },
        { slot: 4, item: null },
    ]);
    const [showInventory, setShowInventory] = useState(false);
    const [showDungeonSelector, setShowDungeonSelector] = useState(false);
    const [showSkillBar, setShowSkillBar] = useState(false);
    const [showQuestPanel, setShowQuestPanel] = useState(false);
    const [showCodeViewer, setShowCodeViewer] = useState(false);
    const [activeBuffs, setActiveBuffs] = useState<ActiveBuff[]>([]);
    const [isAutoAttack, setIsAutoAttack] = useState(false);
    const [combatStats, setCombatStats] = useState<CombatStats>({
        totalDamage: 0,
        killCount: 0,
        critCount: 0,
        hitCount: 0,
        startTime: Date.now(),
        dps: 0,
    });
    const [minimapData, setMinimapData] = useState<MinimapData | null>(null);
    const [quests, setQuests] = useState<Quest[]>([
        {
            id: 'daily_kill_50',
            title: 'ëª¬ìŠ¤í„° ì‚¬ëƒ¥ê¾¼',
            description: 'ëª¬ìŠ¤í„° 50ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'kill', target: 'any', current: 0, required: 50 }],
            rewards: { exp: 500, gold: 200 },
            completed: false,
            claimed: false,
        },
        {
            id: 'daily_kill_200',
            title: 'í•™ì‚´ì',
            description: 'ëª¬ìŠ¤í„° 200ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'kill', target: 'any', current: 0, required: 200 }],
            rewards: { exp: 2000, gold: 1000 },
            completed: false,
            claimed: false,
        },
        {
            id: 'daily_gold',
            title: 'ê³¨ë“œ ìˆ˜ì§‘ê°€',
            description: 'ê³¨ë“œë¥¼ 1000 íšë“í•˜ì„¸ìš”',
            type: 'daily',
            objectives: [{ type: 'collect', target: 'gold', current: 0, required: 1000 }],
            rewards: { exp: 300, gold: 500 },
            completed: false,
            claimed: false,
        },
        {
            id: 'main_level_10',
            title: 'ì„±ì¥ì˜ ì‹œì‘',
            description: 'ë ˆë²¨ 10ì— ë„ë‹¬í•˜ì„¸ìš”',
            type: 'main',
            objectives: [{ type: 'level', target: 'player', current: 1, required: 10 }],
            rewards: { exp: 1000, gold: 500 },
            completed: false,
            claimed: false,
        },
        {
            id: 'main_level_50',
            title: 'ìˆ™ë ¨ìì˜ ê¸¸',
            description: 'ë ˆë²¨ 50ì— ë„ë‹¬í•˜ì„¸ìš”',
            type: 'main',
            objectives: [{ type: 'level', target: 'player', current: 1, required: 50 }],
            rewards: { exp: 10000, gold: 5000 },
            completed: false,
            claimed: false,
        },
    ]);

    // ê²Œì„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    const handlePlayerUpdate = useCallback((stats: PlayerStats) => {
        setPlayerStats(stats);
        // ë ˆë²¨ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        setQuests(prev => prev.map(quest => {
            if (quest.objectives[0].type === 'level') {
                const newCurrent = stats.level;
                const completed = newCurrent >= quest.objectives[0].required;
                return {
                    ...quest,
                    objectives: [{ ...quest.objectives[0], current: newCurrent }],
                    completed,
                };
            }
            return quest;
        }));
    }, []);

    const handleAddItem = useCallback((item: InventoryItem) => {
        setInventory((prev) => {
            const existing = prev.find((i) => i.id === item.id);
            if (existing) {
                return prev.map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity + item.quantity } : i
                );
            }
            return [...prev, item];
        });
    }, []);

    const handleGoldChange = useCallback((amount: number) => {
        setPlayerStats((prev) => {
            const newGold = prev.gold + amount;
            // ê³¨ë“œ í€˜ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            if (amount > 0) {
                setQuests(prevQuests => prevQuests.map(quest => {
                    if (quest.objectives[0].type === 'collect' && quest.objectives[0].target === 'gold') {
                        const newCurrent = Math.min(quest.objectives[0].current + amount, quest.objectives[0].required);
                        return {
                            ...quest,
                            objectives: [{ ...quest.objectives[0], current: newCurrent }],
                            completed: newCurrent >= quest.objectives[0].required,
                        };
                    }
                    return quest;
                }));
            }
            return { ...prev, gold: newGold };
        });
    }, []);

    const handleMonsterKilled = useCallback(() => {
        setQuests(prev => prev.map(quest => {
            if (quest.objectives[0].type === 'kill') {
                const newCurrent = Math.min(quest.objectives[0].current + 1, quest.objectives[0].required);
                return {
                    ...quest,
                    objectives: [{ ...quest.objectives[0], current: newCurrent }],
                    completed: newCurrent >= quest.objectives[0].required,
                };
            }
            return quest;
        }));
    }, []);

    const handleCombatStatsUpdate = useCallback((stats: CombatStats) => {
        setCombatStats(stats);
    }, []);

    const handleMinimapUpdate = useCallback((data: MinimapData) => {
        setMinimapData(data);
    }, []);

    const handleAutoAttackToggle = useCallback((enabled: boolean) => {
        setIsAutoAttack(enabled);
    }, []);

    const handleAddBuff = useCallback((buff: ActiveBuff) => {
        setActiveBuffs(prev => {
            const existing = prev.find(b => b.id === buff.id);
            if (existing) {
                return prev.map(b => b.id === buff.id ? buff : b);
            }
            return [...prev, buff];
        });
    }, []);

    // í€˜ìŠ¤íŠ¸ ë³´ìƒ ìˆ˜ë ¹
    const handleClaimQuest = useCallback((questId: string) => {
        const quest = quests.find(q => q.id === questId);
        if (quest && quest.completed && !quest.claimed) {
            // ë³´ìƒ ì§€ê¸‰
            if (quest.rewards.exp) {
                setPlayerStats(prev => ({
                    ...prev,
                    exp: prev.exp + quest.rewards.exp!,
                }));
            }
            if (quest.rewards.gold) {
                setPlayerStats(prev => ({
                    ...prev,
                    gold: prev.gold + quest.rewards.gold!,
                }));
            }
            // í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì²˜ë¦¬
            setQuests(prev => prev.map(q =>
                q.id === questId ? { ...q, claimed: true } : q
            ));
        }
    }, [quests]);

    // ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸
    useEffect(() => {
        const interval = setInterval(() => {
            setSkills((prev) =>
                prev.map((skill) => ({
                    ...skill,
                    currentCooldown: Math.max(0, skill.currentCooldown - 100),
                }))
            );
            // ë²„í”„ ì‹œê°„ ì—…ë°ì´íŠ¸
            setActiveBuffs(prev =>
                prev
                    .map(buff => ({ ...buff, remainingTime: buff.remainingTime - 0.1 }))
                    .filter(buff => buff.remainingTime > 0)
            );
        }, 100);
        return () => clearInterval(interval);
    }, []);

    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            // ESC í‚¤ ì²˜ë¦¬ - ì—´ë¦° ëª¨ë‹¬ì„ ìˆœì„œëŒ€ë¡œ ë‹«ìŒ
            if (e.key === 'Escape') {
                if (showInventory) {
                    setShowInventory(false);
                    return;
                }
                if (showSkillBar) {
                    setShowSkillBar(false);
                    return;
                }
                if (showQuestPanel) {
                    setShowQuestPanel(false);
                    return;
                }
                if (showCodeViewer) {
                    setShowCodeViewer(false);
                    return;
                }
                // ë˜ì „ ì…€ë ‰í„° í† ê¸€
                setShowDungeonSelector(prev => !prev);
                return;
            }

            if (e.key.toLowerCase() === 'i') {
                setShowInventory((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'w' && !e.ctrlKey) {
                setShowSkillBar((prev) => !prev);
            }
            if (e.key.toLowerCase() === 'j') {
                setShowQuestPanel((prev) => !prev);
            }

            // í€µìŠ¬ë¡¯ ì‚¬ìš©
            const quickSlotKeys = ['q', 'e', 'r', 't', 'f'];
            const keyIndex = quickSlotKeys.indexOf(e.key.toLowerCase());
            if (keyIndex !== -1) {
                const slot = quickSlots[keyIndex];
                if (slot.item && slot.item.type === 'consumable') {
                    useQuickSlotItem(keyIndex);
                }
            }

            // ìŠ¤í‚¬ ì‚¬ìš© (1-9)
            const skillIndex = parseInt(e.key) - 1;
            if (skillIndex >= 0 && skillIndex < skills.length) {
                useSkill(skillIndex);
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [quickSlots, skills, showInventory, showDungeonSelector, showSkillBar, showQuestPanel, showCodeViewer]);

    // ìŠ¤í‚¬ ì‚¬ìš©
    const useSkill = (index: number) => {
        const skill = skills[index];
        if (!skill) return;
        if (skill.currentCooldown > 0) return;
        if (playerStats.mp < skill.mpCost) return;
        if (playerStats.level < skill.requiredLevel) return;

        // MP ì†Œëª¨
        setPlayerStats((prev) => ({
            ...prev,
            mp: prev.mp - skill.mpCost,
        }));

        // ì¿¨ë‹¤ìš´ ì‹œì‘
        setSkills((prev) =>
            prev.map((s, i) =>
                i === index ? { ...s, currentCooldown: s.cooldown } : s
            )
        );

        // í ìŠ¤í‚¬ ì²˜ë¦¬
        if (skill.id === 'heal') {
            setPlayerStats((prev) => ({
                ...prev,
                hp: Math.min(prev.maxHp, prev.hp + 30),
            }));
        }

        // ë²„í”„ ìŠ¤í‚¬ ì²˜ë¦¬
        if (skill.id === 'battle_cry') {
            const buff: ActiveBuff = {
                id: 'battle_cry_buff',
                name: 'ì „íˆ¬í•¨ì„±',
                icon: 'ğŸ“¯',
                duration: 10,
                remainingTime: 10,
                effect: { attack: 50 },
            };
            handleAddBuff(buff);
            GameEventBus.emit('ADD_BUFF', buff);
        }

        // ê²Œì„ì— ìŠ¤í‚¬ ì´ë²¤íŠ¸ ì „ë‹¬
        GameEventBus.emit('USE_SKILL', skill);
    };

    // í€µìŠ¬ë¡¯ ì•„ì´í…œ ì‚¬ìš©
    const useQuickSlotItem = (slotIndex: number) => {
        const slot = quickSlots[slotIndex];
        if (!slot.item) return;

        const item = slot.item;
        if (item.effect) {
            setPlayerStats((prev) => ({
                ...prev,
                hp: Math.min(prev.maxHp, prev.hp + (item.effect?.hp || 0)),
                mp: Math.min(prev.maxMp, prev.mp + (item.effect?.mp || 0)),
            }));
        }

        // ì¸ë²¤í† ë¦¬ì—ì„œ ìˆ˜ëŸ‰ ê°ì†Œ
        setInventory((prev) =>
            prev
                .map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i
                )
                .filter((i) => i.quantity > 0)
        );

        // í€µìŠ¬ë¡¯ ì—…ë°ì´íŠ¸
        setQuickSlots((prev) =>
            prev.map((s, i) => {
                if (i === slotIndex) {
                    const remainingItem = inventory.find(
                        (inv) => inv.id === item.id && inv.quantity > 1
                    );
                    return { ...s, item: remainingItem || null };
                }
                return s;
            })
        );
    };

    // í€µìŠ¬ë¡¯ì— ì•„ì´í…œ ë“±ë¡
    const assignToQuickSlot = (slotIndex: number, item: InventoryItem) => {
        setQuickSlots((prev) =>
            prev.map((s, i) => (i === slotIndex ? { ...s, item } : s))
        );
    };

    // ë˜ì „ ì„ íƒ
    const handleSelectDungeon = (dungeonLevel: number) => {
        setShowDungeonSelector(false);
        setCombatStats({
            totalDamage: 0,
            killCount: 0,
            critCount: 0,
            hitCount: 0,
            startTime: Date.now(),
            dps: 0,
        });
        GameEventBus.emit('CHANGE_SCENE', {
            scene: 'DungeonScene',
            data: { dungeonLevel },
        });
        setCurrentScene('dungeon');
    };

    // ë§ˆì„ë¡œ ê·€í™˜
    const handleReturnToTown = () => {
        setShowDungeonSelector(false);
        setMinimapData(null);
        GameEventBus.emit('CHANGE_SCENE', { scene: 'TownScene' });
        setCurrentScene('town');
    };

    // Phaser ê²Œì„ ì´ˆê¸°í™”
    useEffect(() => {
        if (gameRef.current) return;

        gameRef.current = new Phaser.Game(gameConfig);

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        GameEventBus.on('PLAYER_UPDATE', handlePlayerUpdate);
        GameEventBus.on('ADD_ITEM', handleAddItem);
        GameEventBus.on('GOLD_CHANGE', handleGoldChange);
        GameEventBus.on('MONSTER_KILLED', handleMonsterKilled);
        GameEventBus.on('COMBAT_STATS_UPDATE', handleCombatStatsUpdate);
        GameEventBus.on('MINIMAP_UPDATE', handleMinimapUpdate);
        GameEventBus.on('AUTO_ATTACK_TOGGLE', handleAutoAttackToggle);
        GameEventBus.on('ADD_BUFF', handleAddBuff);
        GameEventBus.on('SCENE_CHANGED', (scene: string) => setCurrentScene(scene));
        GameEventBus.on('TOGGLE_DUNGEON_MENU', () => setShowDungeonSelector(prev => !prev));
        GameEventBus.on('TOGGLE_INVENTORY', () => setShowInventory(prev => !prev));
        GameEventBus.on('TOGGLE_SKILL_MENU', () => setShowSkillBar(prev => !prev));
        GameEventBus.on('TOGGLE_QUEST_PANEL', () => setShowQuestPanel(prev => !prev));

        return () => {
            GameEventBus.off('PLAYER_UPDATE', handlePlayerUpdate);
            GameEventBus.off('ADD_ITEM', handleAddItem);
            GameEventBus.off('GOLD_CHANGE', handleGoldChange);
            GameEventBus.off('MONSTER_KILLED', handleMonsterKilled);
            GameEventBus.off('COMBAT_STATS_UPDATE', handleCombatStatsUpdate);
            GameEventBus.off('MINIMAP_UPDATE', handleMinimapUpdate);
            GameEventBus.off('AUTO_ATTACK_TOGGLE', handleAutoAttackToggle);
            GameEventBus.off('ADD_BUFF', handleAddBuff);
            gameRef.current?.destroy(true);
            gameRef.current = null;
        };
    }, [handlePlayerUpdate, handleAddItem, handleGoldChange, handleMonsterKilled, handleCombatStatsUpdate, handleMinimapUpdate, handleAutoAttackToggle, handleAddBuff]);

    return (
        <div className= "relative w-screen h-screen overflow-hidden bg-black" >
        {/* Phaser ê²Œì„ ì»¨í…Œì´ë„ˆ */ }
        < div id = "game-container" className = "absolute inset-0" />

            {/* React UI ì˜¤ë²„ë ˆì´ */ }
            < HUD
    playerStats = { playerStats }
    quickSlots = { quickSlots }
    skills = { skills }
    currentScene = { currentScene }
    activeBuffs = { activeBuffs }
    isAutoAttack = { isAutoAttack }
    combatStats = { currentScene === 'dungeon' ? combatStats : undefined
}
minimapData = { currentScene === 'dungeon' ? minimapData : undefined}
      />

{/* ì¸ë²¤í† ë¦¬ */ }
{
    showInventory && (
        <Inventory
          items={ inventory }
    onClose = {() => setShowInventory(false)
}
onUseItem = {(item) => {
    if (item.type === 'consumable' && item.effect) {
        setPlayerStats((prev) => ({
            ...prev,
            hp: Math.min(prev.maxHp, prev.hp + (item.effect?.hp || 0)),
            mp: Math.min(prev.maxMp, prev.mp + (item.effect?.mp || 0)),
        }));
        setInventory((prev) =>
            prev
                .map((i) =>
                    i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i
                )
                .filter((i) => i.quantity > 0)
        );
    }
}}
onAssignQuickSlot = { assignToQuickSlot }
gold = { playerStats.gold }
    />
      )}

{/* ìŠ¤í‚¬ ë°” */ }
{
    showSkillBar && (
        <SkillBar
          skills={ skills }
    playerLevel = { playerStats.level }
    playerMp = { playerStats.mp }
    onClose = {() => setShowSkillBar(false)
}
onUseSkill = { useSkill }
    />
      )}

{/* ë˜ì „ ì„ íƒ */ }
{
    showDungeonSelector && (
        <DungeonSelector
          playerLevel={ playerStats.level }
    onSelect = { handleSelectDungeon }
    onClose = {() => setShowDungeonSelector(false)
}
onReturnToTown = { currentScene === 'dungeon' ? handleReturnToTown : undefined}
        />
      )}

{/* í€˜ìŠ¤íŠ¸ íŒ¨ë„ */ }
{
    showQuestPanel && (
        <QuestPanel
          quests={ quests }
    onClose = {() => setShowQuestPanel(false)
}
onClaimReward = { handleClaimQuest }
    />
      )}

{/* ì½”ë“œ ë·°ì–´ */ }
{
    showCodeViewer && (
        <CodeViewer onClose={ () => setShowCodeViewer(false) } />
      )
}

{/* ì½”ë“œ ë³´ê¸° ë²„íŠ¼ */ }
<button
        onClick={ () => setShowCodeViewer(true) }
className = "absolute bottom-4 left-4 px-3 py-2 bg-gray-800 hover:bg-gray-700 text-white text-sm rounded-lg border border-gray-600 transition-colors z-50"
    >
        ğŸ“‹ ì½”ë“œ ë³´ê¸°
    </button>
    </div>
  );
}

export default App;
4. src / game / GameConfig.ts
TypeScript

import Phaser from 'phaser';
import { BootScene } from './scenes/BootScene';
import { TownScene } from './scenes/TownScene';
import { DungeonScene } from './scenes/DungeonScene';

export const gameConfig: Phaser.Types.Core.GameConfig = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: 1920,
    height: 1080,
    pixelArt: true,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { x: 0, y: 0 },
            debug: false,
        },
    },
    scene: [BootScene, TownScene, DungeonScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
};
5. src / game / GameEventBus.ts
TypeScript

type EventCallback = (...args: unknown[]) => void;

class EventBus {
    private events: Map<string, EventCallback[]> = new Map();

    on(event: string, callback: EventCallback) {
        if (!this.events.has(event)) {
            this.events.set(event, []);
        }
        this.events.get(event)!.push(callback);
    }

    off(event: string, callback: EventCallback) {
        const callbacks = this.events.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    emit(event: string, ...args: unknown[]) {
        const callbacks = this.events.get(event);
        if (callbacks) {
            callbacks.forEach((callback) => callback(...args));
        }
    }
}

export const GameEventBus = new EventBus();
6. src / game / scenes / BootScene.ts
TypeScript

import Phaser from 'phaser';

export class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }

    preload() {
        // ë¡œë”© ë°” í‘œì‹œ
        const width = this.cameras.main.width;
        const height = this.cameras.main.height;

        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(width / 2 - 160, height / 2 - 25, 320, 50);

        const loadingText = this.add.text(width / 2, height / 2 - 50, 'ë¡œë”© ì¤‘...', {
            fontSize: '20px',
            color: '#ffffff',
        });
        loadingText.setOrigin(0.5, 0.5);

        this.load.on('progress', (value: number) => {
            progressBar.clear();
            progressBar.fillStyle(0x00ff00, 1);
            progressBar.fillRect(width / 2 - 150, height / 2 - 15, 300 * value, 30);
        });

        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.destroy();
        });

        // ë™ì ìœ¼ë¡œ í…ìŠ¤ì²˜ ìƒì„±
        this.createTextures();
    }

    createTextures() {
        // í”Œë ˆì´ì–´ ìºë¦­í„° (ë°”ëŒì˜ ë‚˜ë¼ ìŠ¤íƒ€ì¼ - ë” ì…ì²´ì ì¸ ë””ìì¸)
        const playerGraphics = this.make.graphics({ x: 0, y: 0 });

        // ê·¸ë¦¼ì
        playerGraphics.fillStyle(0x000000, 0.3);
        playerGraphics.fillEllipse(24, 60, 32, 12);

        // ì‹ ë°œ
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRoundedRect(12, 52, 10, 8, 2);
        playerGraphics.fillRoundedRect(26, 52, 10, 8, 2);

        // ë‹¤ë¦¬ (ë°”ì§€)
        playerGraphics.fillStyle(0x2d3a4a);
        playerGraphics.fillRect(14, 40, 8, 14);
        playerGraphics.fillRect(26, 40, 8, 14);
        // ë°”ì§€ ì£¼ë¦„
        playerGraphics.fillStyle(0x232d3a);
        playerGraphics.fillRect(15, 42, 2, 10);
        playerGraphics.fillRect(27, 42, 2, 10);

        // ë„í¬ (í•œë³µ ìŠ¤íƒ€ì¼ - ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼)
        playerGraphics.fillStyle(0x3498db);
        playerGraphics.fillRoundedRect(8, 20, 32, 24, 4);
        // ë„í¬ ì–´ë‘ìš´ ë¶€ë¶„
        playerGraphics.fillStyle(0x2980b9);
        playerGraphics.fillRoundedRect(8, 20, 10, 24, 4);
        // ë„í¬ ë°ì€ ë¶€ë¶„
        playerGraphics.fillStyle(0x5dade2);
        playerGraphics.fillRoundedRect(30, 22, 8, 18, 2);

        // í—ˆë¦¬ë  (ê¸ˆìƒ‰)
        playerGraphics.fillStyle(0xf39c12);
        playerGraphics.fillRect(8, 38, 32, 4);
        playerGraphics.fillStyle(0xe67e22);
        playerGraphics.fillRect(8, 40, 32, 2);
        // í—ˆë¦¬ë  ë§¤ë“­
        playerGraphics.fillStyle(0xf1c40f);
        playerGraphics.fillCircle(24, 40, 4);
        playerGraphics.fillStyle(0xe67e22);
        playerGraphics.fillCircle(24, 40, 2);

        // ì†Œë§¤ (ë„“ì€ í•œë³µ ì†Œë§¤)
        playerGraphics.fillStyle(0x3498db);
        playerGraphics.fillEllipse(6, 28, 10, 14);
        playerGraphics.fillEllipse(42, 28, 10, 14);
        playerGraphics.fillStyle(0x5dade2);
        playerGraphics.fillEllipse(8, 26, 6, 8);
        playerGraphics.fillEllipse(40, 26, 6, 8);

        // ì†
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillCircle(4, 34, 4);
        playerGraphics.fillCircle(44, 34, 4);
        playerGraphics.fillStyle(0xf5cba7);
        playerGraphics.fillCircle(3, 33, 2);
        playerGraphics.fillCircle(43, 33, 2);

        // ëª©
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillRect(20, 14, 8, 8);

        // ì–¼êµ´ (ë” ë””í…Œì¼í•˜ê²Œ)
        playerGraphics.fillStyle(0xfad7a0);
        playerGraphics.fillRoundedRect(14, 2, 20, 18, 6);
        // ì–¼êµ´ ìŒì˜
        playerGraphics.fillStyle(0xf5cba7);
        playerGraphics.fillRoundedRect(14, 10, 20, 8, 4);

        // ë¨¸ë¦¬ì¹´ë½ (ìƒíˆ¬ ìŠ¤íƒ€ì¼)
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRoundedRect(12, 0, 24, 10, 4);
        // ìƒíˆ¬
        playerGraphics.fillStyle(0x2c2c3e);
        playerGraphics.fillEllipse(24, -2, 12, 8);
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillEllipse(24, -4, 8, 6);
        // ë¨¸ë¦¬ì¹´ë½ í•˜ì´ë¼ì´íŠ¸
        playerGraphics.fillStyle(0x3d3d5c);
        playerGraphics.fillRect(16, 2, 2, 4);

        // ëˆˆ (ë” í‘œí˜„ë ¥ ìˆê²Œ)
        playerGraphics.fillStyle(0xffffff);
        playerGraphics.fillEllipse(18, 8, 5, 4);
        playerGraphics.fillEllipse(30, 8, 5, 4);
        playerGraphics.fillStyle(0x2c2c3e);
        playerGraphics.fillCircle(19, 8, 2);
        playerGraphics.fillCircle(31, 8, 2);
        // ëˆˆ í•˜ì´ë¼ì´íŠ¸
        playerGraphics.fillStyle(0xffffff);
        playerGraphics.fillCircle(20, 7, 1);
        playerGraphics.fillCircle(32, 7, 1);

        // ëˆˆì¹
        playerGraphics.fillStyle(0x1a1a2e);
        playerGraphics.fillRect(16, 4, 6, 1);
        playerGraphics.fillRect(28, 4, 6, 1);

        // ì…
        playerGraphics.fillStyle(0xc0392b);
        playerGraphics.fillRect(22, 14, 4, 1);

        // ë³¼ í„°ì¹˜
        playerGraphics.fillStyle(0xf1948a, 0.5);
        playerGraphics.fillCircle(16, 12, 2);
        playerGraphics.fillCircle(32, 12, 2);

        playerGraphics.generateTexture('player', 48, 64);
        playerGraphics.destroy();

        // NPC í…ìŠ¤ì²˜ë“¤ ìƒì„±
        this.createNPCTexture('npc_blacksmith', 0x8B4513, 0xDC143C, 'ğŸ”¨'); // ëŒ€ì¥ì¥ì´
        this.createNPCTexture('npc_innkeeper', 0xDAA520, 0x8B0000, 'ğŸº'); // ì£¼ëª¨
        this.createNPCTexture('npc_alchemist', 0x9932CC, 0x4B0082, 'âš—ï¸'); // ì—°ê¸ˆìˆ ì‚¬
        this.createNPCTexture('npc_sage', 0x4169E1, 0x000080, 'ğŸ“–'); // ë„ì‚¬
        this.createNPCTexture('npc_merchant', 0x228B22, 0x006400, 'ğŸ’°'); // ì¡í™”ìƒ

        // ëª¬ìŠ¤í„° í…ìŠ¤ì²˜ë“¤ ìƒì„±
        this.createMonsterTexture('monster_slime', 0x00ff00, 'slime');
        this.createMonsterTexture('monster_bat', 0x8B4513, 'bat');
        this.createMonsterTexture('monster_wolf', 0x808080, 'wolf');
        this.createMonsterTexture('monster_ghost', 0xE8E8E8, 'ghost');
        this.createMonsterTexture('monster_goblin', 0x90EE90, 'goblin');
        this.createMonsterTexture('monster_orc', 0x556B2F, 'orc');
        this.createMonsterTexture('monster_skeleton', 0xFFFACD, 'skeleton');
        this.createMonsterTexture('monster_demon', 0x8B0000, 'demon');
        this.createMonsterTexture('monster_dragon', 0xFF4500, 'dragon');
        this.createMonsterTexture('monster_boss', 0x4B0082, 'boss');

        // ì•„ì´í…œ í…ìŠ¤ì²˜
        this.createItemTexture('item_gold', 0xFFD700);
        this.createItemTexture('item_potion', 0xFF0000);
        this.createItemTexture('item_weapon', 0xC0C0C0);

        // ì´í™íŠ¸ í…ìŠ¤ì²˜
        this.createEffectTexture('effect_slash', 0xFFFFFF);
        this.createEffectTexture('effect_fire', 0xFF4500);
        this.createEffectTexture('effect_heal', 0x00FF00);
        this.createEffectTexture('effect_thunder', 0xFFFF00);
        this.createEffectTexture('effect_ice', 0x00FFFF);

        // íƒ€ì¼ í…ìŠ¤ì²˜
        this.createTileTexture('tile_grass', 0x228B22, 0x32CD32);
        this.createTileTexture('tile_stone', 0x696969, 0x808080);
        this.createTileTexture('tile_dungeon', 0x2F2F2F, 0x3D3D3D);
    }

    createNPCTexture(key: string, bodyColor: number, accentColor: number, _icon: string) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        // ê·¸ë¦¼ì
        graphics.fillStyle(0x000000, 0.3);
        graphics.fillEllipse(24, 60, 32, 12);

        // ì‹ ë°œ
        graphics.fillStyle(0x1a1a2e);
        graphics.fillRoundedRect(12, 52, 10, 8, 2);
        graphics.fillRoundedRect(26, 52, 10, 8, 2);

        // ë‹¤ë¦¬
        graphics.fillStyle(0x2d3a4a);
        graphics.fillRect(14, 40, 8, 14);
        graphics.fillRect(26, 40, 8, 14);

        // ëª¸ì²´
        graphics.fillStyle(bodyColor);
        graphics.fillRoundedRect(8, 20, 32, 24, 4);

        // ì•ì¹˜ë§ˆ/ì•¡ì„¼íŠ¸
        graphics.fillStyle(accentColor);
        graphics.fillRect(14, 28, 20, 14);

        // í—ˆë¦¬ë 
        graphics.fillStyle(0xf39c12);
        graphics.fillRect(8, 38, 32, 4);

        // ì†Œë§¤
        graphics.fillStyle(bodyColor);
        graphics.fillEllipse(6, 28, 10, 14);
        graphics.fillEllipse(42, 28, 10, 14);

        // ì†
        graphics.fillStyle(0xfad7a0);
        graphics.fillCircle(4, 34, 4);
        graphics.fillCircle(44, 34, 4);

        // ëª©
        graphics.fillStyle(0xfad7a0);
        graphics.fillRect(20, 14, 8, 8);

        // ì–¼êµ´
        graphics.fillStyle(0xfad7a0);
        graphics.fillRoundedRect(14, 2, 20, 18, 6);

        // ë¨¸ë¦¬ì¹´ë½/ëª¨ì
        graphics.fillStyle(0x1a1a2e);
        graphics.fillRoundedRect(12, 0, 24, 8, 4);

        // ëˆˆ
        graphics.fillStyle(0x2c2c3e);
        graphics.fillCircle(19, 8, 2);
        graphics.fillCircle(31, 8, 2);

        // ì…
        graphics.fillStyle(0xc0392b);
        graphics.fillRect(22, 14, 4, 1);

        graphics.generateTexture(key, 48, 64);
        graphics.destroy();
    }

    createMonsterTexture(key: string, color: number, type: string) {
        const graphics = this.make.graphics({ x: 0, y: 0 });
        const size = 40;

        // ê·¸ë¦¼ì
        graphics.fillStyle(0x000000, 0.4);
        graphics.fillEllipse(size / 2, size - 4, size * 0.8, 8);

        switch (type) {
            case 'slime':
                // ìŠ¬ë¼ì„ ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, size * 0.8, size * 0.6);
                // í•˜ì´ë¼ì´íŠ¸
                graphics.fillStyle(0xffffff, 0.6);
                graphics.fillEllipse(size / 2 - 6, size / 2 - 2, 8, 6);
                // ëˆˆ
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 5, size / 2 + 2, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 + 2, 3);
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(size / 2 - 4, size / 2 + 1, 1);
                graphics.fillCircle(size / 2 + 6, size / 2 + 1, 1);
                break;

            case 'bat':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2, 16, 12);
                // ë‚ ê°œ
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillTriangle(size / 2 - 8, size / 2, 2, size / 2 - 10, 2, size / 2 + 6);
                graphics.fillTriangle(size / 2 + 8, size / 2, size - 2, size / 2 - 10, size - 2, size / 2 + 6);
                // ê·€
                graphics.fillStyle(color);
                graphics.fillTriangle(size / 2 - 6, size / 2 - 6, size / 2 - 10, size / 2 - 14, size / 2 - 2, size / 2 - 6);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 6, size / 2 + 10, size / 2 - 14, size / 2 + 2, size / 2 - 6);
                // ëˆˆ
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 4, size / 2, 2);
                graphics.fillCircle(size / 2 + 4, size / 2, 2);
                break;

            case 'wolf':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, 28, 18);
                // ë¨¸ë¦¬
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2 + 10, size / 2 - 2, 10);
                // ì£¼ë‘¥ì´
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).lighten(20).color);
                graphics.fillEllipse(size / 2 + 16, size / 2, 8, 5);
                // ê·€
                graphics.fillStyle(color);
                graphics.fillTriangle(size / 2 + 4, size / 2 - 8, size / 2 + 8, size / 2 - 16, size / 2 + 12, size / 2 - 8);
                graphics.fillTriangle(size / 2 + 10, size / 2 - 8, size / 2 + 14, size / 2 - 16, size / 2 + 18, size / 2 - 8);
                // ëˆˆ
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 8, size / 2 - 4, 2);
                // ê¼¬ë¦¬
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2 - 14, size / 2 - 2, 10, 6);
                break;

            case 'ghost':
                // ëª¸ì²´ (ë°˜íˆ¬ëª… íš¨ê³¼)
                graphics.fillStyle(color, 0.8);
                graphics.fillEllipse(size / 2, size / 2 - 2, 24, 20);
                // ê¼¬ë¦¬ ë¶€ë¶„ (ë¬¼ê²° í˜•íƒœ)
                graphics.fillTriangle(size / 2 - 12, size / 2 + 6, size / 2 - 6, size + 2, size / 2, size / 2 + 6);
                graphics.fillTriangle(size / 2, size / 2 + 6, size / 2 + 6, size + 2, size / 2 + 12, size / 2 + 6);
                // ëˆˆ
                graphics.fillStyle(0x000000);
                graphics.fillEllipse(size / 2 - 5, size / 2 - 2, 6, 8);
                graphics.fillEllipse(size / 2 + 5, size / 2 - 2, 6, 8);
                // ì…
                graphics.fillEllipse(size / 2, size / 2 + 6, 8, 4);
                break;

            case 'goblin':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 10, size / 2 - 4, 20, 20, 4);
                // ë¨¸ë¦¬
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2 - 8, 12);
                // ê·€ (ë¾°ì¡±í•˜ê²Œ)
                graphics.fillTriangle(size / 2 - 12, size / 2 - 8, size / 2 - 18, size / 2 - 16, size / 2 - 8, size / 2 - 12);
                graphics.fillTriangle(size / 2 + 12, size / 2 - 8, size / 2 + 18, size / 2 - 16, size / 2 + 8, size / 2 - 12);
                // ëˆˆ
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 1);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 1);
                // ì½”
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillCircle(size / 2, size / 2 - 6, 3);
                break;

            case 'orc':
                // ëª¸ì²´ (ê·¼ìœ¡ì§ˆ)
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 14, size / 2 - 2, 28, 22, 4);
                // ë¨¸ë¦¬
                graphics.fillCircle(size / 2, size / 2 - 10, 14);
                // í„±
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(10).color);
                graphics.fillRect(size / 2 - 8, size / 2 - 4, 16, 6);
                // ì´ë¹¨
                graphics.fillStyle(0xffffff);
                graphics.fillTriangle(size / 2 - 6, size / 2 - 4, size / 2 - 4, size / 2 + 2, size / 2 - 2, size / 2 - 4);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 4, size / 2 + 4, size / 2 + 2, size / 2 + 2, size / 2 - 4);
                // ëˆˆ
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 12, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 - 12, 3);
                break;

            case 'skeleton':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillRect(size / 2 - 6, size / 2 - 4, 12, 18);
                // ê°ˆë¹„ë¼ˆ
                graphics.fillStyle(0x000000);
                for (let i = 0; i < 4; i++) {
                    graphics.fillRect(size / 2 - 5, size / 2 - 2 + i * 4, 10, 1);
                }
                // ë¨¸ë¦¬ (í•´ê³¨)
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2 - 10, 10);
                // ëˆˆêµ¬ë©
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                // ì½”
                graphics.fillTriangle(size / 2, size / 2 - 8, size / 2 - 2, size / 2 - 4, size / 2 + 2, size / 2 - 4);
                // ì´ë¹¨
                graphics.fillRect(size / 2 - 5, size / 2 - 3, 10, 2);
                break;

            case 'demon':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillRoundedRect(size / 2 - 12, size / 2 - 4, 24, 22, 4);
                // ë¨¸ë¦¬
                graphics.fillCircle(size / 2, size / 2 - 10, 12);
                // ë¿”
                graphics.fillStyle(0x2c0000);
                graphics.fillTriangle(size / 2 - 10, size / 2 - 14, size / 2 - 14, size / 2 - 26, size / 2 - 6, size / 2 - 14);
                graphics.fillTriangle(size / 2 + 10, size / 2 - 14, size / 2 + 14, size / 2 - 26, size / 2 + 6, size / 2 - 14);
                // ëˆˆ
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 3);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 3);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 4, size / 2 - 10, 1);
                graphics.fillCircle(size / 2 + 4, size / 2 - 10, 1);
                // ë‚ ê°œ
                graphics.fillStyle(0x4a0000);
                graphics.fillTriangle(size / 2 - 12, size / 2, 0, size / 2 - 14, 0, size / 2 + 8);
                graphics.fillTriangle(size / 2 + 12, size / 2, size, size / 2 - 14, size, size / 2 + 8);
                break;

            case 'dragon':
                // ëª¸ì²´
                graphics.fillStyle(color);
                graphics.fillEllipse(size / 2, size / 2 + 4, 30, 20);
                // ë¨¸ë¦¬
                graphics.fillCircle(size / 2 + 12, size / 2 - 4, 12);
                // ì£¼ë‘¥ì´
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(10).color);
                graphics.fillEllipse(size / 2 + 20, size / 2 - 2, 10, 6);
                // ë¿”
                graphics.fillStyle(0xffd700);
                graphics.fillTriangle(size / 2 + 6, size / 2 - 10, size / 2 + 4, size / 2 - 20, size / 2 + 10, size / 2 - 10);
                graphics.fillTriangle(size / 2 + 14, size / 2 - 10, size / 2 + 12, size / 2 - 20, size / 2 + 18, size / 2 - 10);
                // ëˆˆ
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 14, size / 2 - 6, 3);
                // ë‚ ê°œ
                graphics.fillStyle(Phaser.Display.Color.ValueToColor(color).darken(20).color);
                graphics.fillTriangle(size / 2 - 6, size / 2, size / 2 - 20, size / 2 - 20, size / 2 - 16, size / 2 + 8);
                // ë¶ˆê½ƒ
                graphics.fillStyle(0xff4500);
                graphics.fillCircle(size / 2 + 24, size / 2 - 2, 4);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 + 26, size / 2 - 2, 2);
                break;

            case 'boss':
                // ì™•ê´€
                graphics.fillStyle(0xffd700);
                graphics.fillTriangle(size / 2 - 12, size / 2 - 20, size / 2 - 8, size / 2 - 28, size / 2 - 4, size / 2 - 20);
                graphics.fillTriangle(size / 2, size / 2 - 20, size / 2, size / 2 - 32, size / 2, size / 2 - 20);
                graphics.fillTriangle(size / 2 + 4, size / 2 - 20, size / 2 + 8, size / 2 - 28, size / 2 + 12, size / 2 - 20);
                graphics.fillRect(size / 2 - 12, size / 2 - 20, 24, 6);
                // ë¨¸ë¦¬
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2 - 8, 14);
                // ëª¸ì²´
                graphics.fillRoundedRect(size / 2 - 14, size / 2 + 2, 28, 20, 4);
                // ë§í† 
                graphics.fillStyle(0x4a0082);
                graphics.fillTriangle(size / 2 - 14, size / 2 + 4, size / 2 - 18, size / 2 + 24, size / 2 - 10, size / 2 + 20);
                graphics.fillTriangle(size / 2 + 14, size / 2 + 4, size / 2 + 18, size / 2 + 24, size / 2 + 10, size / 2 + 20);
                // ëˆˆ (ë¶‰ì€ ë¹›)
                graphics.fillStyle(0xff0000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 10, 4);
                graphics.fillCircle(size / 2 + 5, size / 2 - 10, 4);
                graphics.fillStyle(0xffff00);
                graphics.fillCircle(size / 2 - 5, size / 2 - 10, 2);
                graphics.fillCircle(size / 2 + 5, size / 2 - 10, 2);
                break;

            default:
                graphics.fillStyle(color);
                graphics.fillCircle(size / 2, size / 2, size / 2 - 2);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(size / 2 - 5, size / 2 - 4, 3);
                graphics.fillCircle(size / 2 + 5, size / 2 - 4, 3);
        }

        graphics.generateTexture(key, size, size);
        graphics.destroy();
    }

    createItemTexture(key: string, color: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        if (key === 'item_gold') {
            // ê¸ˆí™”
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 16, 8);
            graphics.fillStyle(color);
            graphics.fillCircle(12, 12, 10);
            graphics.fillStyle(0xffa500);
            graphics.fillCircle(12, 12, 7);
            graphics.fillStyle(color);
            graphics.fillCircle(12, 12, 4);
            // $ ê¸°í˜¸
            graphics.fillStyle(0xffa500);
            graphics.fillRect(10, 8, 4, 8);
        } else if (key === 'item_potion') {
            // í¬ì…˜ ë³‘
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 14, 6);
            graphics.fillStyle(0x8B4513);
            graphics.fillRect(8, 2, 8, 4);
            graphics.fillStyle(color);
            graphics.fillRoundedRect(6, 6, 12, 16, 4);
            graphics.fillStyle(0xffffff, 0.4);
            graphics.fillRect(8, 8, 3, 8);
        } else {
            // ë¬´ê¸° (ê²€)
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(12, 22, 10, 6);
            graphics.fillStyle(color);
            graphics.fillRect(10, 2, 4, 16);
            graphics.fillStyle(0x8B4513);
            graphics.fillRect(6, 16, 12, 4);
            graphics.fillRect(10, 18, 4, 4);
        }

        graphics.generateTexture(key, 24, 24);
        graphics.destroy();
    }

    createEffectTexture(key: string, color: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        if (key === 'effect_slash') {
            graphics.fillStyle(color, 0.8);
            graphics.fillTriangle(0, 16, 32, 0, 32, 32);
            graphics.fillStyle(0xffffff, 0.6);
            graphics.fillTriangle(4, 16, 28, 4, 28, 28);
        } else if (key === 'effect_fire') {
            graphics.fillStyle(color);
            graphics.fillCircle(16, 20, 12);
            graphics.fillStyle(0xffff00);
            graphics.fillCircle(16, 18, 8);
            graphics.fillStyle(0xffffff);
            graphics.fillCircle(16, 16, 4);
            // ë¶ˆê½ƒ í˜•íƒœ
            graphics.fillStyle(color);
            graphics.fillTriangle(16, 4, 8, 16, 24, 16);
        } else if (key === 'effect_heal') {
            // ì‹­ìê°€ + í•˜íŠ¸
            graphics.fillStyle(color);
            graphics.fillRect(12, 4, 8, 24);
            graphics.fillRect(4, 12, 24, 8);
            graphics.fillStyle(0xffffff, 0.5);
            graphics.fillRect(14, 6, 4, 20);
            graphics.fillRect(6, 14, 20, 4);
        } else if (key === 'effect_thunder') {
            graphics.fillStyle(color);
            graphics.fillTriangle(16, 0, 8, 16, 20, 14);
            graphics.fillTriangle(12, 12, 4, 32, 24, 18);
            graphics.fillStyle(0xffffff, 0.7);
            graphics.fillTriangle(14, 4, 10, 14, 18, 12);
        } else if (key === 'effect_ice') {
            graphics.fillStyle(color);
            // ëˆˆì†¡ì´ í˜•íƒœ
            graphics.fillRect(14, 2, 4, 28);
            graphics.fillRect(2, 14, 28, 4);
            graphics.fillRect(6, 6, 20, 20);
            graphics.fillStyle(0xffffff);
            graphics.fillCircle(16, 16, 6);
        }

        graphics.generateTexture(key, 32, 32);
        graphics.destroy();
    }

    createTileTexture(key: string, color1: number, color2: number) {
        const graphics = this.make.graphics({ x: 0, y: 0 });

        graphics.fillStyle(color1);
        graphics.fillRect(0, 0, 64, 64);

        // íŒ¨í„´ ì¶”ê°€
        graphics.fillStyle(color2);
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                if ((i + j) % 2 === 0) {
                    graphics.fillRect(i * 8, j * 8, 8, 8);
                }
            }
        }

        // í…Œë‘ë¦¬/ë””í…Œì¼
        graphics.lineStyle(1, Phaser.Display.Color.ValueToColor(color1).darken(30).color, 0.3);
        graphics.strokeRect(0, 0, 64, 64);

        graphics.generateTexture(key, 64, 64);
        graphics.destroy();
    }

    create() {
        this.scene.start('TownScene');
    }
}
7. src / game / scenes / TownScene.ts
TypeScript

import Phaser from 'phaser';
import { GameEventBus } from '../GameEventBus';
import { NPC_DATA } from '../data/npcs';

interface PlayerStats {
    hp: number;
    maxHp: number;
    mp: number;
    maxMp: number;
    level: number;
    exp: number;
    expToNext: number;
    gold: number;
    attack: number;
    defense: number;
}

export class TownScene extends Phaser.Scene {
    private player!: Phaser.Physics.Arcade.Sprite;
    private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
    private npcs: Phaser.Physics.Arcade.Sprite[] = [];
    private playerStats: PlayerStats = {
        hp: 100,
        maxHp: 100,
        mp: 50,
        maxMp: 50,
        level: 1,
        exp: 0,
        expToNext: 100,
        gold: 1000,
        attack: 10,
        defense: 5,
    };
    private nearbyNPC: Phaser.Physics.Arcade.Sprite | null = null;
    private interactionText!: Phaser.GameObjects.Text;
    private dialogueBox: Phaser.GameObjects.Container | null = null;

    constructor() {
        super({ key: 'TownScene' });
    }

    create() {
        // ì›”ë“œ í¬ê¸° ì„¤ì •
        this.physics.world.setBounds(0, 0, 2400, 1800);

        // ë°°ê²½ íƒ€ì¼
        for (let x = 0; x < 2400; x += 64) {
            for (let y = 0; y < 1800; y += 64) {
                this.add.image(x + 32, y + 32, 'tile_grass');
            }
        }

        // ë§ˆì„ ì¤‘ì•™ ê´‘ì¥ (ëŒ íƒ€ì¼)
        for (let x = 800; x < 1600; x += 64) {
            for (let y = 600; y < 1200; y += 64) {
                this.add.image(x + 32, y + 32, 'tile_stone');
            }
        }

        // í”Œë ˆì´ì–´ ìƒì„±
        this.player = this.physics.add.sprite(1200, 900, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.setDepth(10);
        this.player.setScale(1.5);

        // ì¹´ë©”ë¼ ì„¤ì •
        this.cameras.main.setBounds(0, 0, 2400, 1800);
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        this.cameras.main.setZoom(1);

        // NPC ìƒì„±
        this.createNPCs();

        // ì…ë ¥ ì„¤ì •
        this.cursors = this.input.keyboard!.createCursorKeys();
        this.setupInput();

        // ìƒí˜¸ì‘ìš© í…ìŠ¤íŠ¸
        this.interactionText = this.add.text(0, 0, '', {
            fontSize: '16px',
            color: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 8, y: 4 },
        });
        this.interactionText.setDepth(100);
        this.interactionText.setVisible(false);

        // ë§ˆì„ ì´ë¦„ í‘œì‹œ
        const townTitle = this.add.text(1200, 100, 'âš”ï¸ ë°”ëŒì˜ ë§ˆì„ âš”ï¸', {
            fontSize: '36px',
            color: '#ffd700',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 4,
        });
        townTitle.setOrigin(0.5);
        townTitle.setScrollFactor(0.5);

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        GameEventBus.on('CHANGE_SCENE', this.handleSceneChange.bind(this));

        // ì”¬ ì‹œì‘ ì•Œë¦¼
        GameEventBus.emit('SCENE_CHANGED', 'town');
        GameEventBus.emit('PLAYER_UPDATE', this.playerStats);
    }

    createNPCs() {
        const npcPositions = [
            { key: 'blacksmith', x: 900, y: 700, texture: 'npc_blacksmith' },
            { key: 'innkeeper', x: 1100, y: 700, texture: 'npc_innkeeper' },
            { key: 'alchemist', x: 1300, y: 700, texture: 'npc_alchemist' },
            { key: 'sage', x: 1500, y: 700, texture: 'npc_sage' },
            { key: 'merchant', x: 1200, y: 1100, texture: 'npc_merchant' },
        ];

        npcPositions.forEach((npcPos) => {
            const npc = this.physics.add.sprite(npcPos.x, npcPos.y, npcPos.texture);
            npc.setImmovable(true);
            npc.setData('npcKey', npcPos.key);
            npc.setScale(1.5);

            // NPC ì´ë¦„ í‘œì‹œ
            const npcData = NPC_DATA[npcPos.key];
            const nameText = this.add.text(npcPos.x, npcPos.y - 60, npcData.name, {
                fontSize: '14px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2,
            });
            nameText.setOrigin(0.5);

            // NPC ì—­í•  í‘œì‹œ
            const roleText = this.add.text(npcPos.x, npcPos.y - 45, `[${npcData.role}]`, {
                fontSize: '11px',
                color: '#aaaaaa',
                stroke: '#000000',
                strokeThickness: 1,
            });
            roleText.setOrigin(0.5);

            this.npcs.push(npc);
        });
    }

    setupInput() {
        // Spacebar - ìƒí˜¸ì‘ìš©
        this.input.keyboard!.on('keydown-SPACE', () => {
            if (this.nearbyNPC) {
                this.interactWithNPC(this.nearbyNPC);
            }
        });

        // ESC - ë˜ì „ ë©”ë‰´
        this.input.keyboard!.on('keydown-ESC', () => {
            if (this.dialogueBox) {
                this.closeDialogue();
            } else {
                GameEventBus.emit('TOGGLE_DUNGEON_MENU');
            }
        });

        // I - ì¸ë²¤í† ë¦¬
        this.input.keyboard!.on('keydown-I', () => {
            GameEventBus.emit('TOGGLE_INVENTORY');
        });

        // W - ìŠ¤í‚¬ì°½
        this.input.keyboard!.on('keydown-W', () => {
            GameEventBus.emit('TOGGLE_SKILL_MENU');
        });

        // J - í€˜ìŠ¤íŠ¸ì°½
        this.input.keyboard!.on('keydown-J', () => {
            GameEventBus.emit('TOGGLE_QUEST_PANEL');
        });
    }

    handleSceneChange(data: { scene: string; data?: Record<string, unknown> }) {
        if (data.scene === 'DungeonScene') {
            this.scene.start('DungeonScene', data.data);
        }
    }

    interactWithNPC(npc: Phaser.Physics.Arcade.Sprite) {
        const npcKey = npc.getData('npcKey');
        const npcData = NPC_DATA[npcKey];

        if (this.dialogueBox) {
            this.closeDialogue();
            return;
        }

        this.showDialogue(npcData);
    }

    showDialogue(npcData: typeof NPC_DATA[keyof typeof NPC_DATA]) {
        const centerX = this.cameras.main.scrollX + this.cameras.main.width / 2;
        const centerY = this.cameras.main.scrollY + this.cameras.main.height - 150;

        this.dialogueBox = this.add.container(centerX, centerY);
        this.dialogueBox.setDepth(200);

        // ëŒ€í™”ì°½ ë°°ê²½
        const bg = this.add.graphics();
        bg.fillStyle(0x000000, 0.9);
        bg.fillRoundedRect(-400, -80, 800, 160, 16);
        bg.lineStyle(3, 0xffd700);
        bg.strokeRoundedRect(-400, -80, 800, 160, 16);
        this.dialogueBox.add(bg);

        // NPC ì´ë¦„
        const nameText = this.add.text(-380, -65, `${npcData.name} [${npcData.role}]`, {
            fontSize: '20px',
            color: '#ffd700',
            fontStyle: 'bold',
        });
        this.dialogueBox.add(nameText);

        // ëŒ€í™” ë‚´ìš©
        const dialogueText = this.add.text(-380, -35, npcData.dialogue, {
            fontSize: '16px',
            color: '#ffffff',
            wordWrap: { width: 760 },
        });
        this.dialogueBox.add(dialogueText);

        // ìƒì  ì•„ì´í…œ ë¯¸ë¦¬ë³´ê¸°
        if (npcData.shopItems && npcData.shopItems.length > 0) {
            const shopText = this.add.text(-380, 20, 'ğŸ“¦ íŒë§¤ í’ˆëª©:', {
                fontSize: '14px',
                color: '#aaffaa',
            });
            this.dialogueBox.add(shopText);

            const itemsPreview = npcData.shopItems.slice(0, 3).map(item =>
                `${item.icon} ${item.name} (${item.price}G)`
            ).join('  |  ');

            const itemsText = this.add.text
Deployed the project
Show More



ì§€ê¸ˆ ì—¬ê¸° í…ìŠ¤íŠ¸ì°½ì— ì „ì²´ ì½”ë“œ ë³µì‚¬í•  ìˆ˜ ìˆëŠ” ë°•ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤˜

            claude - opus - 4 - 5 - 20251101
í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ëª¨ë“  íŒŒì¼ ë‚´ìš©ì„ í™•ì¸í•˜ê³ , ì½”ë“œë¥¼ í•œë²ˆì— ë³µì‚¬í•  ìˆ˜ ìˆëŠ” í˜ì´ì§€ë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.

ë¨¼ì € ëª¨ë“  íŒŒì¼ë“¤ì„ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.ëª¨ë“  íŒŒì¼ë“¤ì„ ì½ê³  ì½”ë“œ ë³µì‚¬ í˜ì´ì§€ë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.ëª¨ë“  íŒŒì¼ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.ì´ì œ ì½”ë“œë¥¼ í•œë²ˆì— ë³µì‚¬í•  ìˆ˜ ìˆëŠ” í˜ì´ì§€ë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.ì´ì œ ë¹Œë“œí•˜ì—¬ ì½”ë“œ ë³µì‚¬ í˜ì´ì§€ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.ë¹Œë“œ ì„±ê³µí–ˆìŠµë‹ˆë‹¤! ì½”ë“œ ë³µì‚¬ í˜ì´ì§€ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.

ğŸ“‹ ì½”ë“œ ë³µì‚¬ ê¸°ëŠ¥ ì¶”ê°€ ì™„ë£Œ
ì‚¬ìš© ë°©ë²•
ê²Œì„ í™”ë©´ ì™¼ìª½ í•˜ë‹¨ì— "ğŸ“‹ ì½”ë“œ ë³´ê¸°" ë²„íŠ¼ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.

"ğŸ“‹ ì½”ë“œ ë³´ê¸°" ë²„íŠ¼ í´ë¦­
ëª¨ë“  ì†ŒìŠ¤ ì½”ë“œ íŒŒì¼ ëª©ë¡ì´ ëª¨ë‹¬ë¡œ í‘œì‹œë¨
ì›í•˜ëŠ” íŒŒì¼ì˜ "ë³µì‚¬" ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ í•´ë‹¹ íŒŒì¼ ì½”ë“œê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë¨
            "ğŸ“¦ ì „ì²´ ì½”ë“œ ë³µì‚¬" ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ ëª¨ë“  íŒŒì¼ì˜ ì½”ë“œê°€ í•œë²ˆì— ë³µì‚¬ë¨
ê¸°ëŠ¥ íŠ¹ì§•
            19ê°œ íŒŒì¼ì˜ ì „ì²´ ì†ŒìŠ¤ ì½”ë“œ í¬í•¨
íŒŒì¼ë³„ ê°œë³„ ë³µì‚¬ ê°€ëŠ¥
ì „ì²´ ì½”ë“œ í•œë²ˆì— ë³µì‚¬ ê°€ëŠ¥
ë³µì‚¬ ì„±ê³µ ì‹œ "ë³µì‚¬ë¨!" í”¼ë“œë°± í‘œì‹œ
ê²€ìƒ‰ ê¸°ëŠ¥ìœ¼ë¡œ ì›í•˜ëŠ” íŒŒì¼ ë¹ ë¥´ê²Œ ì°¾ê¸°
ë¬¸ë²• í•˜ì´ë¼ì´íŒ…ëœ ì½”ë“œ í‘œì‹œ
í¬í•¨ëœ íŒŒì¼ ëª©ë¡
ì¹´í…Œê³ ë¦¬	íŒŒì¼
ì„¤ì •	index.html, src / main.tsx, src / App.tsx
ê²Œì„ ì„¤ì •	GameConfig.ts, GameEventBus.ts
ì”¬	BootScene.ts, TownScene.ts, DungeonScene.ts
ë°ì´í„°	items.ts, monsters.ts, npcs.ts, skills.ts
ë§¤ë‹ˆì €	InputManager.ts
UI ì»´í¬ë„ŒíŠ¸	HUD.tsx, Inventory.tsx, DungeonSelector.tsx, SkillBar.tsx, QuestPanel.tsx, CodeViewer.tsx
Deployed the project
Show More



ê°€ì¥ ë§ˆì§€ë§‰ìœ¼ë¡œ ì§  ì½”ë“œë“¤ì„ í•œë²ˆì— ë³µì‚¬í•  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ë°•ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤˜

            claude - opus - 4 - 5 - 20251101
í˜„ì¬ í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ê³  ê°œì„ í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ë“¤ì„ ì°¾ì•„ë³´ê² ìŠµë‹ˆë‹¤.


                Listed 23 files














Show More



ì¶”ê°€ë¡œ ì—…ë°ì´íŠ¸ í•˜ê±°ë‚˜ ê°œì„ í•  ìˆ˜ ìˆëŠ” ë‚´ìš©ë“¤ì„ ìŠ¤ìŠ¤ë¡œ ì°¾ì•„ì„œ ê°œì„ í•´ì¤˜.

                gemini - 3 - pro
I will check the current project files to ensure the resolution, monster spawn rates, and item auto - loot logic are correctly implemented.


                Listed 23 files









Show More



ê²Œì„ì˜ í•´ìƒë„ë¥¼ 1920x1080ìœ¼ë¡œ í’€hdë¡œ ë°”ê¿”ì¤˜
ëª¬ìŠ¤í„°ê°€ ë” ë§ì´ ë‚˜ì˜¤ê²Œí•´ì¤˜
ì•„ì´í…œì´ ë‚˜ì˜¤ë©´ ìŠ¤ìŠ¤ë¡œ ì¸ë²¤í† ë¦¬ì°½ìœ¼ë¡œ ë“¤ì–´ì˜¤ê²Œí•´ì¤˜

            claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second

í˜„ì¬ íŒŒì¼ë“¤ì„ í™•ì¸í•˜ê³  ìš”ì²­ì‚¬í•­ì„ ì ìš©í•˜ê² ìŠµë‹ˆë‹¤.

Reading src / game / config / GameConfig.ts failed








Show More



ê²Œì„ì˜ í•´ìƒë„ë¥¼ 1920x1080ìœ¼ë¡œ í’€hdë¡œ ë°”ê¿”ì¤˜
ëª¬ìŠ¤í„°ê°€ ë” ë§ì´ ë‚˜ì˜¤ê²Œí•´ì¤˜
ì•„ì´í…œì´ ë‚˜ì˜¤ë©´ ìŠ¤ìŠ¤ë¡œ ì¸ë²¤í† ë¦¬ì°½ìœ¼ë¡œ ë“¤ì–´ì˜¤ê²Œí•´ì¤˜
            claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second

í˜„ì¬ íŒŒì¼ë“¤ì„ í™•ì¸í•˜ê³  ëª¨ë“  ê°œì„ ì‚¬í•­ì„ ì ìš©í•˜ê² ìŠµë‹ˆë‹¤.


                Listed 22 files






Show More



ëª¬ìŠ¤í„°ê°€ ë”ìš± ë§ì´ ì  ë˜ì—ˆìœ¼ë©´ ì¢‹ê²Ÿì–´
ì•„ì´í…œì°½ì„ ì—´ë©´ escë²„íŠ¼ìœ¼ë¡œ ëŒ ìˆ˜ ìˆê²Œí•´ì¤˜
ê²Œì„ì˜ í•´ìƒë„ë¥¼ ë” í‚¤ì›Œì¤˜
ë°©í–¥í‚¤ë¡œë§Œ ì›€ì§ì¼ ìˆ˜ ìˆê²Œí•˜ê³  wasdí‚¤ëŠ” ì›€ì§ì´ëŠ” ìš©ë„ë¡œ ì‚¬ìš©í•˜ì§€ ë§ì•„ì¤˜
ì‚¬ìš© ì•„ì´í…œì°½ ì²˜ëŸ¼ ì‚¬ìš© ìŠ¤í‚¬ì°½ë„ ë”°ë¡œ ë§Œë“¤ì–´ì¤˜
ìºë¦­í„°ê°€ ë„ˆë¬´ 1ì°¨ì›ì ìœ¼ë¡œ ì¢€ ë” ì…ì²´ì ìœ¼ë¡œ ë””ìì¸í•´ì¤˜
ë¶€ì¡±í•œ ì ë“¤ ìˆë‹¤ë©´ ê°œì„ í•˜ê±°ë‚˜ í”„ë¡œê·¸ë¨ì„ ì¶”ê°€í•´ì¤˜
            claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 2 seconds

í˜„ì¬ íŒŒì¼ë“¤ì„ í™•ì¸í•˜ê³  ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

Read src / game / scenes / DungeonScene.ts













Show More



í˜¹ì‹œ ìºë¦­í„°ì˜ ë””ìì¸ì„ ì…í˜€ì¤„ ìˆ˜ ì—†ëŠ”ê±¸ê¹Œ ?

                ê·¸ë¦¬ê³  escë¥¼ ëˆŒëŸ¬ì„œ ì„¤ì •í™”ë©´ì„ ì—´ë©´ ë‹¤ì‹œ escë¥¼ ëˆŒëŸ¬ì„œ ì„¤ì •í™”ë©´ì„ ë’¤ë¡œê°€ê±°ë‚˜ ë‹«ì„ ìˆ˜ ìˆê²Œí•´ì¤˜

ëª¬ìŠ¤í„° ì  ë„ ë„ˆë¬´ ëŠë ¤ ë” ë§ì€ ëª¬ìŠ¤í„°ê°€ ì¶œí˜„í•  ìˆ˜ ìˆê²Œ í•´ì¤˜

            claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 1 second


Listed 19 files







Show More



ì‹¤í–‰ì´ ë˜ì§€ ì•Šê³  ìˆëŠ”ë°

            claude - opus - 4 - 5 - 20251101 - thinking - 32k

Thought for 2 seconds


Listed 8 files



Show More



            [ê°œë°œ LLMì—ê²Œ ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸ ëª…ë ¹ì–´]
í”„ë¡œì íŠ¸ í™˜ê²½:

Tech Stack: React(Vite), Phaser 3, TypeScript, Tailwind CSS
            Path: src / game ë‚´ë¶€ì— ê²Œì„ ë¡œì§, src / componentsì— React UI êµ¬í˜„ ì˜ˆì •
ìš”ì²­ ì‚¬í•­:
í˜„ì¬ êµ¬ì¶•ëœ ê¸°ë³¸ ë¼ˆëŒ€ ìœ„ì— "ë°”ëŒì˜ ë‚˜ë¼"ì™€ ê°™ì€ ê³ ì „ 2D MMORPG ëŠë‚Œì˜ ì‹±ê¸€ RPG ê²Œì„ì„ êµ¬í˜„í•˜ë ¤ê³  í•©ë‹ˆë‹¤.ì•„ë˜ì˜ ì„¸ë¶€ ê¸°íš ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ í•„ìš”í•œ ë°ì´í„° êµ¬ì¡°(Data Structure), í•µì‹¬ ë¡œì§(Core Logic), ê·¸ë¦¬ê³  UI ì—°ë™ ì½”ë“œë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.

ê²Œì„í”Œë ˆì´ ë° ì¡°ì‘(Controls & Interaction)
            ëª©í‘œ: ë§ˆìš°ìŠ¤ ì—†ì´ í‚¤ë³´ë“œ ìœ„ì£¼ì˜ í”Œë ˆì´ê°€ ê°€ëŠ¥í•´ì•¼ í•˜ë©°, ì¸ë²¤í† ë¦¬ ê´€ë¦¬ ë“± íŠ¹ì • ìƒí™©ì—ì„œë§Œ ë§ˆìš°ìŠ¤ë¥¼ ë³‘í–‰í•©ë‹ˆë‹¤.
ê¸°ë³¸ ì´ë™: í™”ì‚´í‘œ í‚¤ ë˜ëŠ” WASD.
                ìƒí˜¸ì‘ìš©(Spacebar):
NPCì™€ ì¶©ëŒ ë²”ìœ„(Overlap) ë‚´ì— ìˆì„ ë•Œ: ëŒ€í™” ì‹œì‘.
ê·¸ ì™¸ì˜ ìƒí™©: ê¸°ë³¸ ê³µê²© ì‹¤í–‰.
ìŠ¤í‚¬ ì‚¬ìš©(1~9): ìˆ«ìí‚¤ë¥¼ ëˆ„ë¥´ë©´ ì¿¨íƒ€ì„ê³¼ ë§ˆë‚˜ë¥¼ ì†Œëª¨í•˜ì—¬ ìŠ¤í‚¬ ë°œë™ + í™”ë ¤í•œ ì´í™íŠ¸(Phaser Particle / Sprite Animation) ì¶œë ¥.
                í€µìŠ¬ë¡¯(Q, W, E, R, T): ë“±ë¡ëœ ì†Œëª¨í’ˆ(í¬ì…˜, ì£¼ë¬¸ì„œ) ì¦‰ì‹œ ì‚¬ìš©.
ë©”ë‰´ í˜¸ì¶œ:
            ESC: ì‚¬ëƒ¥í„° ì´ë™ ë©”ë‰´(Dungeon Selector) í˜¸ì¶œ.
                I: ì¸ë²¤í† ë¦¬ ì°½(React Overlay) í˜¸ì¶œ / ë‹«ê¸°.
2. ë§ˆì„ ë° NPC ë°ì´í„° êµ¬ì„±(Town & NPCs)
TownSceneì— ë°°ì¹˜í•  NPC ë°ì´í„°ì™€ ìƒì  ì‹œìŠ¤í…œì„ src / game / data / npcs.tsì™€ ê°™ì€ íŒŒì¼ë¡œ ì •ì˜í•´ ì£¼ì„¸ìš”.

                ëŒ€ì¥ì¥ì´(Weapon Merchant):
            ì—­í• : ë¬´ê¸° / ë°©ì–´êµ¬ íŒë§¤ ë° ìˆ˜ë¦¬.
                íŒë§¤í’ˆ: ëª©ë„(Lv1), ì‚¬ë¯¸ì¸ê³¡(Lv50), ìš©ë§ˆì œêµ¬ê²€(Lv99) ë“± ë ˆë²¨ êµ¬ê°„ë³„ ì¥ë¹„.
                    ì£¼ëª¨ / ì—°ê¸ˆìˆ ì‚¬(Consumables):
            ì—­í• : ì²´ë ¥ / ë§ˆë ¥ íšŒë³µ ì•„ì´í…œ íŒë§¤.
                íŒë§¤í’ˆ: ë™ë™ì£¼(ì´ˆê¸‰), ë§‰ê±¸ë¦¬(ì¤‘ê¸‰), ì²´ë ¥íšŒë³µì‹œì•½(ê³ ê¸‰).
                    ë„ì‚¬(Skill Master):
            ì—­í• : ìŠ¤í‚¬ë¶ íŒë§¤(íŠ¹ì • ë ˆë²¨ ë„ë‹¬ ì‹œ êµ¬ë§¤ ê°€ëŠ¥).
                ì¡í™”ìƒ(General Merchant):
            ì—­í• : ê·€í™˜ ì£¼ë¬¸ì„œ, ê°ì • ë‹ë³´ê¸° ë“± ìœ í‹¸ë¦¬í‹° ì•„ì´í…œ.
3. ì‚¬ëƒ¥í„° ë° ë˜ì „ ì‹œìŠ¤í…œ(Dungeon System)
ë¬¼ë¦¬ì ì¸ ë§µ ì´ë™ì´ ì•„ë‹Œ, UI ì„ íƒí˜• í…”ë ˆí¬íŠ¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ì£¼ì„¸ìš”.

ì´ë™ ë°©ì‹: ESC í‚¤ ì…ë ¥ -> React ëª¨ë‹¬ ì°½ íŒì—… -> ì‚¬ëƒ¥í„° ëª©ë¡ ì„ íƒ -> í•´ë‹¹ ë‚œì´ë„ì˜ DungeonSceneìœ¼ë¡œ ë°ì´í„°(ëª¬ìŠ¤í„° ë ˆë²¨, ë“œëí…Œì´ë¸”)ë¥¼ ì „ë‹¬í•˜ë©° ì”¬ ì „í™˜.
ë ˆë²¨ ë””ìì¸: 1Lv ~300Lvê¹Œì§€ 5ë ˆë²¨ ë‹¨ìœ„ë¡œ êµ¬ê°„ ë¶„ë¦¬(ì´ 60ê°œ êµ¬ê°„).
                ì˜ˆ: [ì´ˆë³´ì ì‚¬ëƒ¥í„°(1 - 5Lv)], [ì¥êµ´(6 - 10Lv)], ..., [í‰ê°€(96 - 100Lv)] ...
            ìŠ¤ì¼€ì¼ë§: ë˜ì „ ë ˆë²¨ì´ ì˜¤ë¥¼ìˆ˜ë¡ ëª¬ìŠ¤í„°ì˜ HP, ê³µê²©ë ¥, ê²½í—˜ì¹˜ íšë“ëŸ‰ì´ ì§€ìˆ˜ í•¨ìˆ˜ì ìœ¼ë¡œ ì¦ê°€í•˜ë„ë¡ ìˆ˜ì‹(Formula)ì„ ì§œì£¼ì„¸ìš”.
4. ì¸ë²¤í† ë¦¬ ë° í€µìŠ¬ë¡¯ UI(Inventory & Hotbar)
Phaser í™”ë©´ ìœ„ì— Reactë¡œ ì˜¤ë²„ë ˆì´ UIë¥¼ êµ¬í˜„í•´ ì£¼ì„¸ìš”.

                ì¸ë²¤í† ë¦¬(I Key):
ê·¸ë¦¬ë“œ í˜•íƒœì˜ ì•„ì´í…œ ëª©ë¡ í‘œì‹œ.
ê° ì•„ì´í…œì€ ì•„ì´ì½˜, ì´ë¦„, ìˆ˜ëŸ‰, ì„¤ëª… í¬í•¨.
                í€µìŠ¬ë¡¯(HUD):
í™”ë©´ í•˜ë‹¨ ì¤‘ì•™ì— Q, W, E, R, T ìŠ¬ë¡¯ í•­ìƒ í‘œì‹œ.
                Drag & Drop: ì¸ë²¤í† ë¦¬ì˜ ì†Œëª¨í’ˆì„ ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì—¬ í€µìŠ¬ë¡¯ì— ë†“ìœ¼ë©´ ë“±ë¡ë˜ë„ë¡ êµ¬í˜„(HTML5 Drag and Drop API í™œìš©).
5. ì„±ì¥ ë° ì „íˆ¬ ì‹œìŠ¤í…œ(Progression & Combat)
            ë ˆë²¨ë§: 1~300 ë ˆë²¨.ê²½í—˜ì¹˜ í…Œì´ë¸” í•„ìš”.
                ì „íˆ¬:
í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„° ê°„ì˜ Hitbox ì¶©ëŒ ì²˜ë¦¬.
ê³µê²© ì‹œ ë°ë¯¸ì§€ í…ìŠ¤íŠ¸(Floating Text) íŒì—….
ëª¬ìŠ¤í„° ì‚¬ë§ ì‹œ í™•ë¥ ì ìœ¼ë¡œ ì•„ì´í…œ / ê³¨ë“œ ë“œë -> í”Œë ˆì´ì–´ê°€ ë°Ÿìœ¼ë©´(Overlap) íšë“.
ì‘ì„± ìš”ì²­ íŒŒì¼ ëª©ë¡:

            src / game / data / items.ts(ì•„ì´í…œ DB)
            src / game / data / monsters.ts(ë ˆë²¨ë³„ ëª¬ìŠ¤í„° ìƒì„± ë¡œì§)
            src / game / managers / InputManager.ts(í‚¤ë³´ë“œ ì¡°ì‘ í†µí•© ê´€ë¦¬)
            src / game / scenes / TownScene.ts(NPC ë°°ì¹˜ ë° ìƒí˜¸ì‘ìš© ì—…ë°ì´íŠ¸)
            src / game / scenes / DungeonScene.ts(ë™ì  ë‚œì´ë„ ìƒì„±)
            src / components / UI / Inventory.tsx(React ì¸ë²¤í† ë¦¬ & ë“œë˜ê·¸ì•¤ë“œë¡­)
            src / App.tsx(Phaserì™€ React UI ê°„ì˜ ìƒíƒœ ë™ê¸°í™” ë¡œì§ í¬í•¨)
ìœ„ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ê³¼ê±° ë°”ëŒì˜ ë‚˜ë¼ì™€ ê°™ì€ ì†ë§›ê³¼ ì„±ì¥ ì¬ë¯¸ë¥¼ ëŠë‚„ ìˆ˜ ìˆëŠ” ì½”ë“œë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.

Ask a follow up...

            Code

